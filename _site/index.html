<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Home
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | Gimin’s Blog</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="시스템 설계와 깊게 공부하는 것을 좋아하는 개발자의 블로그입니다.">
<meta property="og:description" content="시스템 설계와 깊게 공부하는 것을 좋아하는 개발자의 블로그입니다.">
<link rel="canonical" href="http://localhost:4000/">
<meta property="og:url" content="http://localhost:4000/">
<meta property="og:site_name" content="Gimin’s Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:02:36+08:27">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","dateModified":"1900-01-01T00:02:36+08:27","datePublished":"1900-01-01T00:02:36+08:27","description":"시스템 설계와 깊게 공부하는 것을 좋아하는 개발자의 블로그입니다.","headline":"Index","name":"Gimin’s Blog","url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="시스템 설계와 깊게 공부하는 것을 좋아하는 개발자의 블로그입니다.">
        <link rel="preload" href="/assets/img/profile.jpg" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>Gimin's Blog</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/profile.jpg" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    
            
            
            
            
            
            
            
            
            
            
            

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="Architecture">
            <div class="nav-item">
                <a href="/Architecture/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Architecture</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Architecture category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="api-design">
                    <div class="nav-item">
                        <a href="/Architecture/api-design/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>api-design</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="data-modeling-erd">
                    <div class="nav-item">
                        <a href="/Architecture/data-modeling-erd/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>data-modeling-erd</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="security-auth">
                    <div class="nav-item">
                        <a href="/Architecture/security-auth/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>security-auth</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="system-design">
                    <div class="nav-item">
                        <a href="/Architecture/system-design/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>system-design</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Java">
            <div class="nav-item">
                <a href="/Java/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Java</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="Spring Boot">
            <div class="nav-item">
                <a href="/Spring%20Boot/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Spring Boot</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Spring Boot category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="Security">
                    <div class="nav-item">
                        <a href="/Spring%20Boot/Security/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Security</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Trouble Shooting">
            <div class="nav-item">
                <a href="/Trouble%20Shooting/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Trouble Shooting</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/Gimini-3">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:gimin1463@naver.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                
                
                    <li><a aria-label="My Instagram" href="https://www.instagram.com/gimin0226">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"></path></svg>
                    </a></li>
                
                
                
                    <li><a aria-label="My LinkedIn" href="https://www.linkedin.com/in/g-m-627b33392">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg>
                    </a></li>
                
            </ul>
            <hr>
            <span>
                Copyright © 2024 | <a href="https://github.com/byanko55/jekyll-theme-satellite">Yankos</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>
        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        All Posts
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Trouble%20Shooting/docker-redis-network-dns.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/docker-redis-network-dns.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Trouble%20Shooting/docker-redis-network-dns.html"><h1 class="title_post">[Docker Troubleshooting] Spring Redis UnknownHostException 해결기: Spring 앱과 Redis의 외부 네트워크와 DNS 스코프 문제</h1></a>
                        <a href="/Trouble%20Shooting/docker-redis-network-dns.html" class="txt_post">
                            Spring Redis UnknownHostException 해결기:  Spring 앱과 Redis의 외부 네트워크와 DNS 스코프 문제

Redis UnknownHostException 문제를 Docker 네트워크/ DNS 관점에서 추적한 기록

배포 환경에서 Spring 앱이 Redis에 붙지 못하며 UnknownHostException: redis가 발생했다. 단순한 “Redis 다운” 문제가 아니라, 컨테이너 네트워크와 DNS 스코프가 어긋난 설정 문제였다.

이 글은 실제로 내가 문제를 재현하고, 네트워크를 확인하고, 원인을 좁혀가며 해결한 과정을 정리한 기록이다.



1) 컨테이너가 어떤 네트워크에 붙어있는지 확인

먼저 앱 컨테이너, Redis 컨테이너, MySQL 컨테이너가 각각 어떤 네트워크에 붙어 있는지 확인했다.

docker inspect oneco-redis \
  --format '{{json .NetworkSettings.Networks}}'


출력은 대략 아래와 같았다.

{
  "oneco_oneco-network": {
    "IPAMConfig": null,
    "Links": null,
    "Aliases": [
      "oneco-redis",
      "redis"
    ],
    ...
    "DNSNames": [
      "oneco-redis",
      "redis",
      "0eb40bfab1c1"
    ]
  }
}


확인 결과


  Redis는 네트워크 그룹이 oneco_oneco-network
  MySQL과 Spring 앱은 네트워크 그룹이 oneco-network


였다.

즉, 같은 서비스끼리 서로 다른 “방(네트워크)”에 들어가 있는 상태였다.



그렇다면 도커 네트워크란 무엇일까?

도커 네트워크는 컨테이너들이


  서로 IP로 직접 통신할 수도 있고
  이름(DNS)으로 서로를 찾게 해주는 공간이다.


Spring 앱 컨테이너가 oneco-network라는 방에 들어가 있고

Redis 컨테이너도 같은 oneco-network에 들어가 있으면

두 컨테이너는 이름으로 서로를 찾고 통신할 수 있다.

그래서 먼저 Redis를 oneco-network에 연결했다.

docker network connect oneco-network oneco-redis


이후 Redis도 oneco-network에 연결되었다.



1-1) 추후 안정성을 위해 compose에 외부 네트워크 선언

수동 연결은 재배포/재생성 시 다시 꼬일 수 있으므로

추후에도 안정적으로 유지되도록 docker-compose에도 다음 설정을 추가했다.

networks:
  oneco-network:
    external: true
    name: oneco-network


각 항목의 의미는 다음과 같다.


  networks:
    
      compose에서 사용할 네트워크들을 정의하는 영역
    
  
  oneco-network:
    
      compose 내부에서 참조할 네트워크 키(name)
      서비스에서 networks: [oneco-network]처럼 사용할 때 이 이름을 참조
    
  
  external: true
    
      이 네트워크는 compose가 생성/관리하지 않는다는 의미
      따라서 docker compose up 이전에 해당 네트워크가 미리 존재해야 한다
    
  
  name: oneco-network
    
      도커 엔진에서 실제로 찾을 네트워크 이름을 지정
      프로젝트명 기반 자동 네이밍을 피하고 정확히 이 네트워크를 사용하겠다는 선언
    
  


이렇게 하면 compose로 실행되는 컨테이너들이 동일한 oneco-network에 붙어 문제를 해결할 수 있을 것이라 기대했다.

하지만 다시 실행해보니 여전히 다음 오류가 발생했다.



2) UnknownHostException: redis

원인을 분석해보니,

oneco-network 안에서 redis라는 이름이 해석되지 않아

UnknownHostException: redis가 발생한 상황이었다.



내 inspect 결과를 해석하면

백엔드


  네트워크: oneco-network
  DNSNames: oneco-container-dev-live-gimin


MySQL


  oneco-network에서 alias가 정상적으로 잡힘
    
      Aliases: ["oneco-mysql", "mysql"]
    
  


Redis


  oneco-network 쪽
    
      Aliases: [] ← 핵심
      DNSNames에는 oneco-redis가 존재
    
  
  oneco_oneco-network 쪽
    
      Aliases: ["oneco-redis", "redis"]
    
  


즉, REDIS_HOST=redis로 설정한 상태에서

Spring 앱이 붙어 있는 oneco-network 스코프에서는

redis라는 alias가 없기 때문에 이름 해석이 실패했다.



3) Docker DNS 내부 동작 원리

도커에는 내장 DNS(Embedded DNS)가 있다.


  컨테이너 이름/alias를 이름 해석 대상으로 제공한다.


컨테이너 내부에서 일반적으로 동작하는 흐름은 다음과 유사하다.


  백엔드 앱이 redis로 접속을 시도
  
    OS 레벨에서 이름 해석 호출

    예: getaddrinfo("redis")
  
  컨테이너의 /etc/resolv.conf에 설정된 DNS로 질의
  도커 내장 DNS가 응답


이때 중요한 점은

도커 내장 DNS는 네트워크 스코프로 이름을 관리한다는 것이다.

즉,


  백엔드 컨테이너가 속한 네트워크에서
  redis라는 이름이 등록돼 있어야만
  IP로 변환이 가능하다.


그래서 내 케이스처럼


  Redis 컨테이너가 네트워크에 추가로 붙어 있어도
  그 네트워크 endpoint에 alias(redis)가 없으면
  redis 이름은 해석되지 않는다.


이 단계에서 터지는 게 바로

UnknownHostException이다.

연결 시도 이전에 이름 → IP 변환이 실패한 것이다.



해결책 1) .env의 REDIS_HOST 변경(응급처치)

프론트와 연동 테스트가 급한 상황이라

우선 응급처치로 REDIS_HOST를 바꿔 확인했다.


  oneco-network에서 Redis의 DNSNames에 oneco-redis가 보였으므로
  .env에서


REDIS_HOST=oneco-redis


로 변경했다.

그 결과 문제는 일단 해결되었다.

하지만 이 방식은 근본 해결이 아니라

“우연히 해당 네트워크 스코프에서 해석 가능한 이름을 선택한” 임시 대응이었다.



Alias가 계속 비어있는데 정상 실행되는 이유는 무엇일까?

다시 상태를 확인해 보았다.

docker inspect oneco-redis \
  --format '{{json .NetworkSettings.Networks}}'


{
  "oneco-network": {
    "Aliases": [],
    ...
    "DNSNames": [
      "oneco-redis",
      "0eb40bfab1c1"
    ]
  },
  "oneco_oneco-network": {
    "Aliases": [
      "oneco-redis",
      "redis"
    ],
    ...
    "DNSNames": [
      "oneco-redis",
      "redis",
      "0eb40bfab1c1"
    ]
  }
}


oneco-network에는 alias가 비어 있지만

DNSNames에는 oneco-redis가 존재했다.

즉, .env에서 REDIS_HOST=oneco-redis로 바꾼 이유는

alias에 의존하지 않아도 컨테이너 이름이 해석 가능했기 때문이었다.



alias와 DNSNames는 무엇이 다른가?

alias란?


  특정 네트워크 스코프에서 사용하는 별칭이다.
  
    같은 컨테이너라도 네트워크 A에서는 alias가 있고

    네트워크 B에서는 없을 수 있다.
  


예를 들어


  oneco_oneco-network에는 Aliases: ["oneco-redis", "redis"]
  oneco-network에는 Aliases: []


처럼 네트워크마다 다르게 보일 수 있다.



DNSNames란?


  
    도커 내장 DNS가 해당 네트워크에서

    이 컨테이너를 어떤 이름들로 해석해줄지 보여주는 목록이다.
  
  
    보통 포함되는 값은
    
      컨테이너 이름
      alias
      컨테이너 ID 일부
    
  


예:

"DNSNames": [
  "oneco-redis",
  "redis",
  "0eb40bfab1c1"
]


따라서 alias가 비어 있어도

DNSNames에 컨테이너 이름이 들어 있을 수 있다.



근본 해결: 외부 네트워크에서 alias를 명시적으로 관리

redis alias를 확실히 보장하기 위해

docker-compose에 다음 설정을 추가했다.

services:
  redis:
    networks:
      oneco-network:
        aliases:
          - redis
          - oneco-redis


그리고 다시 compose를 올렸다.

docker compose \
  -f /opt/oneco/docker-compose.gimin.yml \
  -f /opt/oneco/docker-compose.prod.gimin.yml \
  up -d


올린 뒤 inspect를 보면

"Aliases":["oneco-redis","redis","redis","oneco-redis"]


처럼 중복된 항목이 표시되었다.

기능적으로는 동작에 문제가 없었지만

표현이 중복되는 이유를 정리해보면 다음과 같다.



왜 alias가 중복으로 표시됐을까?

Compose는 보통


  프로젝트 전용 기본 네트워크를 만들고
  그 네트워크에서
    
      서비스명(redis)
      컨테이너명(oneco-redis)
    
  


같은 이름을 alias/DNS로 자동 등록해준다.

그래서 처음에 Redis가 붙어 있던

oneco_oneco-network에서는 이런 형태로 자연스럽게 등록돼 있었다.

"Aliases": [
  "oneco-redis",
  "redis"
],
...
"DNSNames": [
  "oneco-redis",
  "redis",
  "0eb40bfab1c1"
]


하지만 나는 Redis를 나중에


  
    외부 네트워크(oneco-network)에

    수동으로 추가 연결하는 과정을 거쳤다.
  


이 연결은 compose 관리 영역 밖에서 생긴 관계라

oneco-network endpoint에는

compose가 자동으로 서비스명 alias를 넣어주지 않았던 것으로 보인다.



최종 정리: 외부 네트워크 선언 + compose 재정렬로 해결

그래서 네트워크 연결을 compose 설정에 명시하고

networks:
  oneco-network:
    external: true
    name: oneco-network


Redis 서비스의 alias를 별도로 덧붙이지 않은 상태에서

다시 compose up을 수행했다.

그 결과

"Aliases":["oneco-redis","redis"]


로 중복 없이 정리된 상태를 확인할 수 있었다.

즉,


  서비스에 외부 네트워크를 명시적으로 붙인 상태에서
  compose up으로 네트워크 엔드포인트가 compose 관리 하에 재조정되며
  서비스명 기반 alias가 정상 반영될 수 있었다


고 판단했다.



결론

이번 문제는 Redis 서버 장애가 아니라


  컨테이너가 서로 다른 네트워크에 붙어 있었고
  같은 네트워크에 붙은 뒤에도
  해당 네트워크 스코프에서 redis alias가 등록되지 않아
  이름 해석이 실패한 케이스였다.


결과적으로


  external network를 명시하고
  compose가 네트워크 엔드포인트를 일관되게 관리하도록 구성해


REDIS_HOST=redis를 안정적으로 유지할 수 있었다.

                        </a>
                        <div class="info-post">
                                <a href="/Trouble%20Shooting" class="category">Trouble Shooting</a>
                            
                                <span class="date">· 2025-12-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Architecture/security-auth/2025-11-30-kakao-login.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/2025-11-30-kakao-login.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Architecture/security-auth/2025-11-30-kakao-login.html"><h1 class="title_post">카카오 OAuth 로그인 흐름 이해하기: JS SDK + Authorization Code 플로우</h1></a>
                        <a href="/Architecture/security-auth/2025-11-30-kakao-login.html" class="txt_post">
                            카카오 로그인 동작과정 분석하기(sdk 방식)

[전제 조건 및 설계 원칙]


  환경 전제
    
      웹 브라우저 기준으로 설명한다.
      
        모바일 앱이라면 authorize() 호출 시 카카오톡 앱이 먼저 실행되고,

        그 안의 WebView에서 kauth.kakao.com 페이지를 띄워 로그인/동의가 진행된다.
      
    
  
  로그인 시작 방식
    
      
        로그인 버튼 클릭 시, 프론트에서 백엔드를 거치지 않고 바로

        Kakao.Auth.authorize() 를 호출한다.
      
      
        이 호출은 브라우저를 https://kauth.kakao.com/oauth/authorize 로 이동시킨다.

        → 프론트 → (백엔드 패스) → Kakao Auth Server
      
    
  
  인가 코드 수신 주체
    
      redirect_uri 를 프론트 주소로 설정한다.
      
        동의 완료 후, Kakao Auth Server는

        302 Location: {redirect_uri}?code=... 로 응답한다.
      
      브라우저가 이 redirect_uri(프론트 URL)로 이동하면서 인가 코드는 먼저 프론트가 받는다.
      프론트는 URL에서 code를 추출해 백엔드 로그인 API로 전달하여 토큰 발급·회원 처리 등을 진행한다.
    
  


전체 아키텍처



1. 사용자가 로그인 버튼 클릭: 프론트 → Kakao Auth 서버

사용자가 우리 사이트에서 “카카오로 로그인” 버튼을 누른다.

JS SDK 방식에서는 이 버튼 클릭이 결국 카카오 JS SDK의 authorize 호출로 이어지고,

이 함수는 브라우저의 주소를 카카오 Auth 서버의 인가 엔드포인트로 바꾸어 버린다.

Kakao.Auth.authorize({
	redirectUri: 'http://localhost:5173/oauth/kakao/callback'
});


결국 이 호출은 다음과 같이 나가게 된다.

https://kauth.kakao.com/oauth/authorize?
	client_id=
	&amp;redirect_uri=http://localhost:5173/oauth/kakao/callback
	&amp;response_type=code 


여기서 중요한 점은:


  이 시점에는 우리 백엔드를 전혀 거치지 않는다는 것.
  브라우저는 곧바로 kauth.kakao.com으로 이동해서 카카오 Auth 서버와 통신한다는 것.


로그인 시작부터 브라우저 ↔ 카카오 Auth 서버가 직접 붙는 구조다.

1-1. 로그인 안 되어 있을 때 : Auth → Account → Auth 왕복



카카오 Auth 서버 입장에서, 브라우저가 보낸 인가 코드 요청을 받았다.


  Auth 서버는 이 브라우저에 카카오 계정 로그인 세션이 있는지 확인한다.
  로그인 세션이 없다면, “먼저 카카오 계정 로그인을 시켜야 한다”고 판단한다.
  
    그래서 Auth 서버는 브라우저에게 “카카오 Account 서버로 가라”는 의미의 302 리다이렉트 응답을 보낸다.

    이때 응답의 Location 헤더에는 Account 서버의 로그인 URL과 함께 continue라는 파라미터가 붙어 있다.
  



  continue 파라미터



  로그인까지 끝난 뒤 다시 돌아와야 할 Auth 서버의 /oauth/authorize 요청 전체를 그대로 기억해 두는 것



https://accounts.kakao.com/login?
continue=https%3A%2F%2Fkauth.kakao.com%2Foauth%2Fauthorize%3Fclient_id%3Dd2ffdfaa297012904086e71f5d7eda1f%26redirect_uri%3Dhttp%253A%252F%252Flocalhost%253A3000%252Foauth%252Fkakao%252Fcallback%26response_type%3Dcode%26through_account%3Dtrue%26auth_tran_id%3DwbrMy9IcVMYhPjgkbCpf7-TiGF7balKdB--tpTWfCg0VmwAAAZrDiMg9#login


continue= 뒤에 있는 건 전부 URL 인코딩된 문자열이다.


  
    URL 디코더를 통해서 위의 인코딩된 문자열 디코딩 결과

      https://accounts.kakao.com/login?
  continue=https://kauth.kakao.com/oauth/authorize?
  client_id={client_id}&amp;
  redirect_uri=http://localhost:5173/oauth/kakao/callback&amp;
  response_type=code&amp;
  through_account=true&amp;
  auth_tran_id=wbrMy9IcVMYhPjgkbCpf7-TiGF7balKdB--tpTWfCg0VmwAAAZrDiMg9#login
    

    
      continue=
    

    → 우리가 원래 쳤던 인가 코드 받는 엔드포인트

    
      client_id=…
    

    →  JS SDK 플로우에서는 JavaScript 키가 client_id로 사용된다.

    
      redirect_uri
    

    → 동의 후 인가 코드를 보내줄 프론트 주소(백으로 설정하면 백주소)

    
      response_type = code
    

    → OAuth2에서 인가 코드 플로우를 쓰겠다는 뜻

    
      through_account = true
    

    → 계정 로그인 서버를 통해서 처리하는 중이다 정도의 카카오 내부 플래그

    
      auth_tran_id=
    

    → 카카오가 이 인증 트랜잭션을 추적하기 위한 내부 트랜잭션 ID
  


브라우저는 Auth 서버가 보내준 Location 값을 그대로 따라가서 Account 서버의 로그인 페이지를 연다.



이제 사용자는 이 페이지에서 카카오 계정 이메일과 비밀번호를 입력하고 로그인 버튼을 누른다.

로그인이 성공하면 Account 서버는 continue에 들어 있던 인가 요청 URL을 꺼내서,

다시 그 URL로 302 리다이렉트를 보낸다.

브라우저는 또 한 번 302 Location을 따라가서 다시 Auth 서버의 /oauth/authorize 로 돌아간다.

로그인 버튼 누른 뒤에 일어나는 일


  사용자는 여기서 아이디 비밀번호를 누르고 로그인 버튼을 누른다.
  
    로그인 버튼을 누르면 이 폼을 Account 서버로 제출한다.

    → 예: POST https://accounts.kakao.com/login 같은 요청
  
  
    Account 서버가 ID/비번 검증해서 로그인 성공 처리하고 내부에서 continue 파라미터에 있던 값을 꺼내서 응답으로 돌려준다.

     HTTP/1.1 302 Found
 Location: https://kauth.kakao.com/oauth/authorize?client_id=...&amp;redirect_uri=...&amp;response_type=code&amp;...
    
  
  
    브라우저는 이 Location 헤더를 보고

    → 자동으로 
  GET https://kauth.kakao.com/oauth/authorize?... 요청을 다시 보냄

     https://kauth.kakao.com/oauth/authorize?
 client_id={client_id}&amp;
 redirect_uri=http://localhost:5173/oauth/kakao/callback&amp;
 response_type=code
    
  


브라우저가 302 응답을 받자마자 순식간에 다음 주소로 이동하기 때문에 육안으로는 볼 수 없다.


  확인 방법
    
      F12를 눌러 개발자 도구를 연다.
      상단 탭 중 Network 탭을 클릭한다.
      Network 탭 상단 메뉴바에 있는 Preserve log (로그 보존) 체크박스를 반드시 체크한다.
        
          이걸 체크하지 않으면, 페이지가 accounts에서 kauth로 이동(리다이렉트)하는 순간 이전 기록이 전부 지워져서 302 응답을 볼 수 없다.
        
      
      이제 브라우저에서 로그인 버튼을 눌러 로그인을 시도한다.
      Network 탭의 리스트 중에서 login 혹은 authorize 라는 이름의 요청을 찾는다.
      Status(상태) 코드가 302 인 항목을 클릭한다.
      오른쪽 상세 창의 Response Headers(응답 헤더) 탭을 보면 Location 항목에 네가 찾던 그 URL(https://kauth.kakao.com/...)이 적혀 있는 것을 확인할 수 있다.
    
  


2. 동의 화면: Auth 서버가 HTML을 내려주고, 브라우저가 렌더링한다.

현재 상태


  브라우저는 카카오 계정에 로그인된 상태다.
  Auth 서버는 인가 코드 요청을 정상적으로 받을 수 있는 상태다.


Auth 서버는 이 요청에 대해 다음과 같이 행동한다.


  
    사용자가 이 앱(우리 서비스)에 처음 접근했다면

    → 어떤 정보(프로필, 이메일 등)를 제공할지 보여주는 동의 화면을 내려준다.
  
  
    이미 예전에 한 번 동의한 앱이라면

    → 동의 화면을 생략하고 바로 인가 코드 발급으로 넘어갈 수 있다.
  


여기서 중요한 점:


  동의 화면은 항상 웹 페이지다.
  서버는 Auth 서버(kauth)에서 HTML을 내려주고,
  클라이언트가 브라우저라면 브라우저가,
카카오톡 앱이라면 카카오톡 앱 안의 WebView가 그 HTML을 렌더링할 뿐이다.


웹 기준에서는 그냥 브라우저에서 카카오 동의 화면 페이지를 보는 것이라고 이해하면 된다.



3. 동의하고 계속하기

사용자가 동의 화면에서 “동의하고 계속하기” 버튼을 누른다.


  브라우저는 이 버튼을 누르면서 Auth 서버로 폼 제출/JS 요청을 보내고,
  Auth 서버는 내부적으로 인가 코드(code)를 하나 발급한 뒤,
  아래와 같이 응답한다.


HTTP/1.1 302 Found
Location: {redirect_uri}?code=AUTH_CODE&amp;state=STATE_VALUE



중요한 점:


  redirect_uri는 우리가 처음 /oauth/authorize 요청에 넘겨줬던 값이다.
  
    Auth 서버는 이 값을 그대로 끌고 와서 뒤에 ?code=...&amp;state=... 를 붙인 뒤

    Location 헤더에 넣는다.
  
  브라우저는 “redirect_uri”라는 개념을 모른다.
    
      302의 Location에 해당하는 URL로 이동할 뿐이다.
    
  




4. redirect_uri가 프론트 일 때

우리는 전제로 redirect_uri를 프론트 주소로 놓았다.

redirect_uri = http://localhost:5173/oauth/kakao/callback


그럼 Auth 서버의 응답은 대략 이렇게 된다.

HTTP/1.1 302 Found
Location: http://localhost:5173/oauth/kakao/callback?code=AUTH_CODE&amp;state=...


브라우저는 이걸 보고:

GET http://localhost:5173/oauth/kakao/callback?code=AUTH_CODE&amp;state=...


를 다시 호출한다.

이 시점에 일어나는 일:


  이 URL에 매핑된 프론트 라우트(React/Vite) 가 로드된다.


이렇게 하면 인가 코드는 백엔드가 직접 받는 것이 아니라, 브라우저(프론트)가 URL로 전달받고 → 백엔드로 다시 넘기는 구조가 된다.



5. 백엔드: 인가 코드 → 액세스 토큰 교환



프론트에서 /api/auth/kakao/login 으로 code를 넘기면,

이제부터는 백엔드(Spring) 의 역할이다.


  
    카카오 Auth 서버의 /oauth/token 엔드포인트를 호출한다.

     POST https://kauth.kakao.com/oauth/token
 Content-Type: application/x-www-form-urlencoded
    
 grant_type=authorization_code
 &amp;client_id=REST_API_KEY
 &amp;redirect_uri=http://localhost:5173/oauth/kakao/callback
 &amp;code=AUTH_CODE
    
    

    여기서 중요한 점:

    
      이때 client_id로 사용하는 것은 REST API 키다.
      프론트(Javascript SDK)에서는 JavaScript 키를 사용한다.
      REST API 키는 백엔드에서만 사용해야 하는 비공개 키다.
    
  
  
    응답으로 액세스 토큰/리프레시 토큰을 받는다.
  


{
"token_type": "bearer",
"access_token": "ACCESS_TOKEN",
"expires_in": 21599,
"refresh_token": "REFRESH_TOKEN",
"refresh_token_expires_in": 5183999,
"scope": "profile_nickname account_email"
}




6. 백엔드: Kakao API Server에서 유저 정보 조회



이제 백엔드는 받은 access_token을 이용해

Kakao API Server (kapi.kakao.com) 에서 유저 정보를 조회한다.

GET https://kapi.kakao.com/v2/user/me
Authorization: Bearer ACCESS_TOKEN
Content-Type: application/x-www-form-urlencoded;charset=utf-8



응답 예시는 대략 이런 형태다.

{
  "id": 1234567890,
  "kakao_account": {
    "profile": {
      "nickname": "홍길동",
      "profile_image_url": "..."
    },
    "email": "example@kakao.com",
    "has_email": true,
    "is_email_valid": true,
    "is_email_verified": true}
}



이 정보를 기반으로 우리 도메인에서:


  SocialAccount 엔티티 (provider=KAKAO, social_user_id=카카오 id) 생성/조회
  Member 엔티티와 1:N 관계로 묶기
  이메일/전화번호로 기존 회원과 연결 여부 판단
  신규 가입이면 Member 생성, 기존 회원이면 해당 Member에 소셜 계정 추가


같은 작업을 수행하면 된다.



7. 우리 서비스 토큰 발급 및 최종응답



마지막으로, 우리 서비스 자체의 로그인 처리를 한다.


  Member / SocialAccount 기준으로 실제 사용자 식별
  우리 서비스용 JWT Access Token / Refresh Token 발급
  프론트로 응답


예:

{
  "accessToken": "OUR_SERVICE_ACCESS_TOKEN",
  "refreshToken": "OUR_SERVICE_REFRESH_TOKEN",
  "member": {
    "id": 100,
    "nickname": "김기민",
    "role": "PARENT"
  }
}



이제 사용자는 “카카오 계정으로 로그인한 우리 서비스 사용자”가 된다.



                        </a>
                        <div class="info-post">
                                <a href="/Architecture" class="category">Architecture</a>
                            
                                <span class="date">· 2025-11-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Architecture/system-design/at-least-once-notification-redis-queue-blmove-idempotency.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/at-least-once-notification-redis-queue-blmove-idempotency.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Architecture/system-design/at-least-once-notification-redis-queue-blmove-idempotency.html"><h1 class="title_post">[시스템 설계] 하루 한 번 알림을 “누락 없이” 보내기 위한 Redis 큐 &amp; 워커 설계</h1></a>
                        <a href="/Architecture/system-design/at-least-once-notification-redis-queue-blmove-idempotency.html" class="txt_post">
                            [시스템 설계] 하루 한 번 알림을 “누락 없이” 보내기 위한 Redis 큐 &amp; 워커 설계

1. 시스템 목표


  “하루에 한 번”과 같이 정해진 알림을 누락 없이 전송한다. (At-least-once Delivery)
  API 서버 장애, DB 장애, 애플리케이션 장애 등 어떤 상황에서도 작업 유실을 방지한다.
  장애 복구 시 발생할 수 있는 중복 발송을 최소화하고, 제어(멱등성)할 수 있도록 설계한다.


2. 아키텍처 설계



[1단계: 생산자 (Scheduler) 영역]


  별도의 스케줄러 스레드가 알림 발송 시간 10분 전에 User 테이블에서 알람 설정 한 유저 정보를 조회한다.
  유저 정보를 조회한 스케줄러는 오늘 알림 설정을 on 한 사용자들에 대해서만 quiz_notification_log 테이블을 생성하고 저장한다. (초기 status=’PENDING’)
  발송 시간이 되면 메인 스케줄러 스레드는 quiz_notification_log 테이블에서 오늘 작업들을 조회한다.
  quiz_notification_log 테이블의 status를 ‘PENDING’에서 ‘QUEUED’로 변경한다.
    
      트랜잭션 처리 함으로써 전부 QUEUED로 변경되도록 한다.
    
  
  트랜잭션으로 상태 변경(‘QUEUED’)된 작업들을 레디스 큐(main-queue)에 푸시한다.
    
      푸시 중간에 서버가 다운되면 보조 스케줄러가 돌면서 status=’QUEUED’인데 10분이 지나도록 SENT로 바뀌지 않은 작업들을 찾아서 다시 큐에 푸시한다. (작업 유실 방지)
        
          updated_at/ created_at 기반으로 판단한다.
        
      
    
  


[2단계: 소비자 (Worker) 영역]


  main-queue에서 worker-N-processing-queue(워커 전용 백업 큐)로 BLMOVE를 통해 원자적 이동을 실행한다.
    
      processing-queue에서는 작업의 모든 과정이 완료되어야만 해당 작업을 삭제한다.
    
  
  워커 스레드가 자신의 processing-queue에서 작업을 가져온다.
    
      processing-queue에서 작업을 가져오는 것은 읽기(LRANGE 등)로 처리한다.
      삭제는 작업의 모든 과정이 완료된 후 마지막에 수행된다.
    
  
  quiz_notification_log 테이블의 status를 ‘QUEUED’에서 ‘PROCESSING’으로 변경한다.
    
      (의미: 작업이 큐에서 꺼내져 처리가 시작되었음을 보장. API 호출 성공 여부는 보장 X)
    
  
  사용자에게 알람을 보내는 API를 호출한다.
  API 응답 결과에 따라 작업을 분기 처리한다.
    
      성공 시: quiz_notification_log 테이블의 status를 ‘PROCESSING’에서 ‘SENT’로 변경한다. (→ 11단계로 이동)
      일시적 실패 시 (5xx 등): retry-queue로 (원자적 이동을 통해) 옮겨지며, retry 전문 워커 스레드에 의해서 재시도 된다.
      영구적 실패 시 (4xx 등): dlq-queue로 (원자적 이동을 통해) 옮겨진다. 개발자가 수동으로 원인 분석 및 버그 수정을 해야 한다.
    
  
  최종 처리 후 processing-queue에서 작업을 삭제한다.
    
      DB status가 ‘SENT’로 상태 변경된 것을 확인한 후, LREM으로 processing-queue에서 해당 작업을 제거한다.
    
  


3. 실패 지점

[생산자(Scheduler) 영역]


  DB 조회 실패
    
      문제: DB 장애로 유저 목록 조회가 실패한다.
      결과: 스케줄러가 아예 시작을 못 한다.
    
  
  큐 등록 실패
    
      문제: 큐 등록을 하다가 중간에 스케줄러가 다운된다.
    
  


[소비자(Worker) 영역]


  큐 작업 확보 문제
    
      문제: BRPOP을  썼을 때, 워커가 작업을 꺼내고 처리(API 호출)하기 직전에 다운된다.
      해결책: BLMOVE를 사용해 작업을 processing-queue로 안전하게 이동시킨다.
    
  
  API 호출 실패
    
      문제: 카카오 서버가 에러를 반환하거나 네트워크가 불안정하다.
      해결책: retry-queue 로 작업을 보내 재시도한다. (최종 실패 시 dlq-queue로 격리)
    
  


[워커가 API 성공 ‘이후’에 실패하는 영역]


  DB 로그 기록 실패
    
      문제: API 호출은 성공했는데 , quiz_notification_log 테이블에 SENT라고 UPDATE 하려는 순간 DB 장애 발생→ 퀴즈는 발송됐지만, DB엔 기록이 안 됐다.
    
  
  작업 완료 처리 실패
    
      문제: API 호출도 성공하고, DB 로그 기록도 성공했다. 이제 processing-queue 에서 작업을 LREM (삭제) 하려던 순간 Redis가 다운된다.
    
  




큐 등록 실패 문제 해결 방안

1. 사전에 발송 대상을 확정 (log 테이블 생성)

스케줄러가 정해진 발송 시간에 User 테이블을 읽는 것이 아니라, 그 이전에 ‘오늘 보낼 작업 목록’을 quiz_notification_log 테이블에 미리 생성해 둔다.


  테이블 : quiz_notification_log
  컬럼: id(PK), user_id(FK), quiz_data, status (PENDING, QUEUED, PROCESSING, SENT, FAILED)
  시간 : 퀴즈 발송 10분 전
  동작: 별도의 스케줄러가 User 테이블을 읽어, 오늘 퀴즈를 받아야 할 목록을 quiz_notification_log에 INSERT 한다. (초기 상태 ‘PENDING’)
  결과: quiz_notification_log 테이블에 오늘 처리해야 할 작업이 status = ‘PENDING’ 상태로 모두 저장된다.


2. 작업 등록 스케줄러

정해진 발송 시간이 되면 메인 스케줄러(Producer)가 동작한다.

이 스케줄러는 User 테이블을 보는 것이 아니라, quiz_notification_log 테이블만 본다.

(만약 사용자가 많으면 한 번에 처리하지 않고, 나눠서 배치로 처리한다)

3. 트랜잭션 관리 &amp; 실패 시 복구

A. DB 트랜잭션


  @Transactional이 시작된다.
  PENDING인 작업을 찾아서(배치면 배치 개수만큼), 다른 스케줄러가 접근하지 못하도록 DB 락을 건다.
    
      User 테이블이 아닌 quiz_notification_log 테이블 락이여서 락 경합이 발생하지 않는다.
    
  
  락을 건 작업들의 status를 QUEUED 로 변경한다.
  트랜잭션이 COMMIT 된다.
    
      만약 1~4번 사이에서 서버가 다운되면?
    
    
      DB 트랜잭션이 롤백된다.
      status는 다시 PENDING 상태로 돌아가고 락도 풀린다.
      Redis에는 아무것도 들어가지 않는다.
      결과: 스케줄러가 재시작되면 이 PENDING 작업 1000개를 다시 처리한다.
        
          @Scheduled(fixedRate = 60000) 으로 스레드 풀에 있는 태스크 스케줄러에게 작업을 할당한 후, while 문에서 PENDING 상태인 작업이 없을 때까지 루프를 돌게 한다.
          예를 들어 서버가 다운되더라도 서버가 재시작한다면 스케줄러가 다시 돌며 실패한 작업들을 PENDING 상태가 없을 때까지 작업을 처리한다.
        
      
    
  


B. Redis 등록 ( DB 커밋 이후)


  A번의 DB 트랜잭션이 성공적으로 COMMIT 되었다 (DB는 QUEUED 상태)
  이제 for 문을 돌며 Redis에 1000개의 작업을 LPUSH 한다.
    
      만약 LPUSH 중간에 서버가 다운되면?
    
    
      DB 상태: 1000개 모두 QUEUED 이다.
      Redis 상태: 600개만 큐에 들어갔다.
      문제: 400개는 QUEUED 상태로 DB에 저장된다(REDIS에는 없음)
      해결책: 보조 스케줄러가 2분마다 돌면서, quiz_notification_log에 status = 'QUEUED' 인데 10분이 지나도록 SENT 로 바뀌지 않은 작업들을 찾는다.
      나머지 400개의 작업을 다시 Redis 큐에 LPUSH 해준다.
      결과: 작업 유실이 복구된다. (최소 1회 보장)
    
  




큐 작업 확보 문제

1. 문제 상황

BRPOP(Blocking Right Pop)은 큐에서 데이터를 꺼내오는 순간 그 데이터는 큐에서 영구적으로 삭제된다.

그래서 워커가 Redis에서 작업을 꺼내와도 워커 서버가 다운되면 작업이 유실된다.

2. BLMOVE (원자적 이동 후 데이터 반환)

두 가지 일을 단 하나의 원자적(Atomic) 명령으로 묶어버린다.


  일 1: main-queue에서 데이터를 꺼낸다. (Pop)→ processing-queue에 데이터를 밀어 넣는다. (Push)
  일 2: 성공한 데이터를, 명령을 요청했던 워커에게 응답으로 즉시 반환한다.


즉 둘 다 성공하거나 둘 다 실패하는 것을 Redis 서버가 보장한다.

동작 순서


  워커
    
      BRPOP 대신 BLMOVE 명령을 실행한다.
      BLMOVE main-queue worker-1-processing-queue RIGHT LEFT 0
    
    
      설명: RIGHT에서 꺼내서(큐 뒤) LEFT로 넣기(큐 앞)
      0의 의미: main-queue에 작업이 들어올 때까지 영원히 대기한다.
      worker 스레드마다 개별 processing-queue를 둔다
      공용으로 두면 갇힌 작업을 누가 어떻게 복구할지 매우 복잡해진다. (A 워커가 특정 작업을 처리중인지 실패했는지 모르기 때문)
    
  
  Redis
    
      task-123을 main-queue에서 삭제함과 동시에 worker-1-processing-queue에 추가한다.(원자적)
      모든 이동이 완료된 후, 워커에게 task-123을 반환한다.
    
  
  워커
    
      task-123을 받고 이제 이 작업이 worker-1-processing-queue에 안전하게 백업된 것을 안다.
      이제 API 호출을 시작한다.
    
  
  워커
    
      성공 시
    
    
      
        API 호출 직전에, DB상태를 QUEUED에서 PROCESSING으로 먼저 변경(UPDATE)한다.

        (만약 이 UPDATE가 실패하면(DB장애, 애플리케이션 서버 다운 등), API 호출은 일어나지 않았고 큐에도 작업이 남아있으므로 재시작시 100% 안전하다.)
이 UPDATE가 성공한 작업에 대해서만 API 호출을 시작한다.
      
      API 호출이 성공하고, DB 로그(PROCESSING-&gt; SENT) 기록도 성공한다.
      모든 처리가 완료되었으므로, 백업 큐에 있던 작업을 수동으로 삭제해야 한다.
      LREM worker-1-processing-queue 1 task-123
      (의미: worker-1-processing-queue에서 task-123 값 1개를 찾아서 삭제)
    - 실패 시
      워커 애플리케이션 다운된 후 재시작한다.
      로직 1순위로 worker-1-processing-queue를 먼저 확인한다.
      worker-1-processing-queue에 아까 다운될 때 처리 중이던 task-123이 그대로 남아있는 것을 발견한다.
      이 task-123  작업을 다시 처리(API 호출)하기 시작한다.
    
  


주의사항


  
    다시 작업을 꺼낼때는 읽기로 꺼내기(삭제는 최종)

    만약 워커가 다운된 후 processing-queue에서 작업을 또다시 꺼내어 처리한다면 다시 워커가 다운된다면 데이터가 유실된다.

    → 따라서 실패 후 재처리 로직은 삭제가 아닌 읽기이다.

    재시작된 워커 동작 원리

    
      작업 확인
        
          processing-queue에서 작업을 삭제하지 않고 읽기만 한다.
          명령어: LRANGE worker-1-processing-queue 0 0
          (의미: worker-1-processing-queue의 첫 번째 작업을 삭제하지 말고, 보여줘)
        
        
          워커가 main-queue에서 작업을 확보할 때 단 1개의 작업만 processing-queue로 가져온다.
            
              워커 하나는 동시에 하나의 작업만 처리한다.
            
          
          api 호출 → DB 로그 변경 → 큐에서 데이터 삭제 이 과정이 끝나야 processing-queue에서 작업을 삭제한다.
        
      
      작업 재처리
        
          워커는 task-123이 큐에 안전하게 남아있는 상태여서, API 호출을 다시 시도한다.
        
      
      만약 또 실패하면?
        
          워커가 API 호출 중에 또 다운되어도, 1번 단계에서 작업을 삭제한 적이 없으므로 task-123은 processing-queue에 여전히 안전하게 남아있는다.
        
      
      최종 성공 시
        
          API 호출과 DB 기록이 모두 성공했을 때, 워커가 그제서야 processing-queue에서 작업 삭제한다.
          명령어: LREM worker-1-processing-queue 1 task-123
        
      
    
  
  
    워커 영구 장애 시 processing-queue 작업 정체

    현재는 worker-1-processing-queue 와 같이 워커별로 개별 큐를 두고 있다. (작업 소유권 명확해짐)

    문제점: 만약 worker-1이  작업을 processing-queue로 가져간 직후, 서버가 다운되어 영원히 복구되지 않으면 task-123 은 worker-1-processing-queue에 영원히 갇히게 된다. 다른 워커는 이 작업을 처리할 수 없다.

    보완책:

    
      일정 시간 이상 processing-queue 에 머물러 있는 작업을 감지하는 별도의 모니터링 스케줄러가 필요하다.
      이 스케줄러는 모든 worker-*-processing-queue 를 주기적으로 스캔한다.
      만약 특정 작업이 Timeout을 초과했다면, 해당 워커가 영구 장애 상태라고 간주하고 LMOVE를 사용해 해당 작업을 다시 main-queue 로 원자적으로 이동시킨다.
      타임아웃 초과 시 LMOVE worker-1-processing-queue main-queue LEFT RIGHT로 원자적으로 복구한다.
      이를 통해 다른 건강한 워커가 해당 작업을 이어받아 처리할 수 있다.
    
  




API 호출 실패 해결 방안

API 호출 실패를 일시적 실패와 영구적 실패로 분리하여, 시스템 전체가 멈추는 것을 막는다.

1. 즉시 재시도 하지 않는 이유


  API 호출이 실패했을 때, 그 자리에서 while 루프문을 돌며 즉시 재시도를 하는 것이다.
  문제점: 워커 스레드는 계속 실패한 작업에만 묶여있게 되므로 그동안 main-queue에 쌓인 나머지 작업은 처리하지 못한다.


2. retry-queue의 역할 (일시적 실패 처리)

retry-queue는 지금 당장 말고 나중에 다시 시도할 작업들을 모아둔다.


  API 호출이 일시적 실패로 끝났을 때 사용
    
      503 Service Unavailable (서버 과부하), Network Timeout (네트워크 불안정)
    
  
  동작:
    
      워커가 processing-queue의 작업으로 API 호출했으나 에러를 받는다.
      워커가 이 작업을 즉시 재시도 하지 않는다.
      대신, processing-queue 에서 이 작업을 꺼내어 retry-queue에 넣는다.
      워커는 이 실패한 작업을 잊고, 즉시 main-queue로 돌아가 다음 작업을 처리한다.
    
  
  retry-queue의 처리:
    
      이 큐는 별도의 워커(혹은 main-queue가 비었을 때만 이 큐를 보는 워커)가 처리한다.
      retry-queue에서 작업을 꺼낼 때는 지연을 주어서 꺼낸다.(ex: 5분 뒤에 다시 시도)
    
  


3. dlq-queue의 역할 (영구적 실패 격리)

dlq-queue (Dead Letter Queue)는 재시도를 해도 절대 성공할 수 없는 작업들을 모아두는 큐이다.


  API 호출이 영구적 실패로 끝났을 때 사용
    
      400 Bad Request (요청 형식이 잘못됨), 401 Unauthorized (API 키가 틀림), 404 Not Found (카카오 UUID가 존재하지 않음)
    
  
  이건 계속 재시도 해도 똑같이 실패할 것인 작업을 넣는다.
  동작:
    
      워커가 processing-queue의 작업으로 API 호출했으나 400 에러를 받는다.
      워커는 이 작업이 영구적 실패임을 인지한다.
      processing-queue에서 이 작업을 꺼내서 dlq-queue에 넣는다.(원자적)
      이 큐로 이동된 작업은 처리 “실패로 처리 완료된 작업”으로 간주한다. (워커는 main-queue로 복귀)
    
  
  dlq-queue의 처리:
    
      이 큐는 자동으로 처리되지 않는다.
      개발자가 수동으로 이 큐에 쌓인 작업들을 확인하여, 왜 특정 에러가 났는지 원인을 분석하고 버그를 수정한다.
    
  


4. 최대 재시도 횟수 관리

retry-queue에 있는 작업이 5분 뒤에 재시도했는데 또 503 에러를 받을 수도 있다.

→ 무한 재시도를 막아야 한다.

최대 재시도 횟수 로직을 통해 retry-queue와 dlq-queue 를 연결한다.


  최초 작업 페이로드에 retryCount: 0을 포함시킨다.
  N번 재시도 실패하면 영구적 실패로 간주하고 DLQ로 이동시킨다.


전체 흐름


  워커가 main-queue -&gt; processing-queue로 작업을 가져온다.
  API를 호출한다.
    
      (성공): processing-queue에서 작업 삭제. (완료)
      (영구적 실패 / 4xx): processing-queue -&gt; dlq-queue로 이동. (완료-실패)
      (일시적 실패 / 5xx): retryCount를 확인.
        
          count &lt; 3 : retryCount를 1 증가시키고 processing-queue -&gt; retry-queue로 이동.
          count &gt;= 3 : “최종 실패”로 간주. processing-queue -&gt; dlq-queue로 이동.
        
      
    
  


주의사항

processing-queue에서 이 작업을 꺼내어 retry-queue에 넣거나, retry-queue → dlq-queue 에 넣을때도 원자적이지 않으면 데이터가 유실 될 수 있다.

→ 해결책: LMOVE 사용


  main-queue → processing-queue로 가져올 때 BLMOVE를 사용한 것처럼, 다른 큐로 보낼 때도 원자적 이동 명령어를 사용해야 한다.


LMOVE (Non-Blocking) vs BLMOVE (Blocking)


  LMOVE
    
      소스 큐에서 아이템을 POP하여 목적지 큐로 PUSH한다.
      만약 소스 큐가 비어있으면: 즉시 nil(없음)을 반환하고 명령이 종료
    
  
  BLMOVE
    
      소스 큐에서 아이템을 POP하여 목적지 큐로 PUSH한다.
      만약 소스 큐가 비어있으면: 명령이 즉시 종료되지 않고, 데이터가 들어올 때까지 지정된 시간동안 대기한다.
    
  




작업 완료 처리 실패 해결 방안

최소 1회 전송을 보장하는 과정에서 중복 발송을 유발하는 실패 시나리오

→ 큐를 더 추가해서 해결하는 것이 아니라, 워커의 로직을 멱등성 있게 설계하여 해결한다.


  멱등성: 같은 작업을 여러 번 수행해도, 그 결과는 1번 수행한 것과 같아야 한다.


즉, 워커가 재시작되어 중복 발송을 시도하더라도, 실제 발송이 2번 일어나지 않게 방어하는 것



멱등성 검사를 통한 해결

워커는 작업을 처리할 때, 무조건 API부터 호출하는 것이 아니라 DB의 ‘최종 상태’를 먼저 확인해야 한다.


  [워커 재시작]
워커 A가 재시작된다.
  [백업 큐 확인]
로직 1순위로 worker-A-processing-queue를 확인(LRANGE 0 0)하고, API 호출/DB 기록/큐 삭제가 모두 실패했던 task-123을 발견한다.
  [멱등성 검사 (Idempotency Check)]
워커 A는 task-123을 보고 API를 바로 호출하지 않는다.
대신, task-123에 포함된 logId (예: 9876)를 가지고 quiz_notification_log DB를 먼저 조회한다.
SELECT status FROM quiz_notification_log WHERE id = 9876;
  [상태 확인 및 결정] 워커 A가 DB에서 조회한 status를 확인한다.
    
      CASE 1: status = 'SENT' (6단계 실패: 큐 삭제만 실패한 경우)
    
  


[방어 로직 실행]

- 워커 A는 API 발송도 성공했고 DB 기록도 성공했음을 알고 Redis 큐에서 삭제만 실패했던 것임을 인지한다.
- **카카오 API 호출을 절대로 하지 않는다. (SKIP)**
- 대신, **실패했던 마지막 단계(큐 삭제)만** 다시 수행한다.
- `LREM worker-A-processing-queue 1 task-123` 명령을 실행하여 백업 큐를 정리한다. - CASE 2: `status = 'PROCESSING'` (5단계 실패: SENT 기록만 실패한 경우)


PROCESSING 상태는 ‘보냈을 수도 있고 안 보냈을 수도 있는’ 애매한 상태라,

최소 1회 보장 원칙 때문에 중복 가능성을 감수하고 재호출한다

[방어 로직 실행]

- 워커 A는 “API 호출은 성공했을 수 있으나, DB SENT 기록은 실패했음”을 인지한다.
- ‘최소 1회 보장’ 원칙에 따라, 이 작업은 완료된 것이 아니므로 재시도한다.
- (중복 발송을 감수하고) API 호출부터 다시 시도한다.
- (API 호출 → DB SENT 변경 → LREM) - CASE 3: `status == 'QUEUED'` (매우 드문 경우: PROCESSING 변경조차 실패한 경우)


[방어 로직 실행]

- 워커 A는 “이 작업은 API 호출 시도조차 못했음”을 인지한다.
- 당연히 API 호출부터 다시 시도한다.
- (DB (`QUEUED` → `PROCESSING` )변경 → API 호출 → DB SENT 변경 → LREM)


주의사항

처음 큐에서 받은 작업이든, 재시작 후 발견한 작업이든, 워커는 항상 API 호출하기 직전에 DB의 status를 확인하는 것이 안전한 멱등성 설계이다.

→ 워커의 처리 로직을 단순하고 통일성 있게 유지할 수 있다.

→ 워커가 작업을 확보한 후 실행하는 로직은 항상 동일해야 한다. (분기 처리를 피함)

결론

워커가 작업 시작 전 DB 상태를 먼저 확인(SELECT)하는 멱등성 검사 로직을 가지고 있으면,
6단계 실패(API 호출과 DB 기록까지 성공)한 작업이 재시도되더라도, 워커가 SENT 상태를 감지하고 API 호출을 건너뛰어 중복 발송을 방지한다.
5단계 실패(API 호출 후 PROCESSING 상태에 멈춤)한 작업은, ‘최소 1회 보장’ 원칙에 따라 중복을 감수하고 재시도하여 메시지 누락을 방지한다.



                        </a>
                        <div class="info-post">
                                <a href="/Architecture" class="category">Architecture</a>
                            
                                <span class="date">· 2025-11-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/firestore-apifuture-future-mono-async-flow.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/firestore-apifuture-future-mono-async-flow.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/firestore-apifuture-future-mono-async-flow.html"><h1 class="title_post">[Firebase/Java] Firestore ApiFuture와 Java Future, 그리고 Reactor Mono까지 – 비동기 흐름 뜯어보기</h1></a>
                        <a href="/Java/firestore-apifuture-future-mono-async-flow.html" class="txt_post">
                            Firestore ApiFuture와 Java Future, 그리고 Reactor Mono까지 – 비동기 흐름 뜯어보기

공모전에서 Firestore를 사용하면서 ApiFuture를 자연스럽게 쓰고 있었다.

그런데 어느 날 Java의 Future와 스레드 풀을 공부하다 보니,

“Firestore가 반환하는 ApiFuture는 도대체 어떤 스레드에서 어떻게 동작하는 걸까?”라는 궁금증이 생겼다.

이 글에서는


  ApiFuture가 Java Future/ListenableFuture와 어떻게 연결되는지
  Firestore SDK가 어떤 스레드에서 네트워크 I/O를 처리하는지
  이 비동기 결과를 Reactor Mono로 감싸면서 어떤 설계 결정을 했는지


를 실제 공모전 프로젝트의 코드를 기준으로 하나씩 뜯어보겠다.



ApiFuture

Firestore에서 ApiFuture는  비동기 작업의 결과를 나타내는 Google의 인터페이스이다.

데이터베이스 읽기/쓰기 같은 Firestore 작업은 네트워크를 통해 이루어지므로 시간이 걸린다.

Firestore의 docRef.set(room)는 내부적으로 백그라운드 스레드에서 네트워크 I/O를 수행하고,

그 결과를 나중에 받을 수 있도록 ApiFuture를 반환한다.

ApiFuture 자체는 비동기 작업의 핸들일 뿐이고, get()을 호출하면 여전히 현재 스레드는 블로킹된다.

대신 addListener / ApiFutures.addCallback을 사용하면 블로킹 없이 콜백 방식으로 결과를 처리할 수 있다.

Future와의 관계

ApiFuture&lt;V&gt;는 Java의 표준 Future&lt;V&gt; 인터페이스를 상속한다.

즉, ApiFuture&lt;V&gt;는 Future&lt;V&gt;의 모든 기능을 가지면서 추가적인 편의 기능을 제공한다.

java.util.concurrent.Future&lt;V&gt;
▲
│ (extends)
com.google.common.util.concurrent.ListenableFuture&lt;V&gt;
▲
│ (extends)
com.google.api.core.ApiFuture&lt;V&gt;


1. Future&lt;V&gt; (Java 표준)

public interface Future&lt;V&gt; {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}




  비동기 작업의 결과를 나타내는 표준 인터페이스이다.
  주요 메서드는 get()이다.
    
      get() 메서드는 결과가 준비될 때까지 현재 스레드를 블로킹 시킨다.
      작업이 끝날 때까지 프로그램이 그 자리에서 멈춰 기다려야 해서 효율이 떨어질 수 있다.
    
  


2. ApiFuture&lt;V&gt; (Google의 확장)

public interface ApiFuture&lt;V&gt; extends Future&lt;V&gt; {
  void addListener(Runnable listener, Executor executor);
}




  Future&lt;V&gt;를 상속하므로, get() 메서드도 가지고 있다.
  핵심 기능 (차이점): addListener(Runnable listener, Executor executor) 메서드를 제공한다.
  이 addListener를 사용하면, 스레드를 차단하고 결과를 기다리는 대신 “작업이 끝나면 이 코드를 실행해줘”라는 콜백(callback)을 등록할 수 있다.
  작업이 완료되면(성공하든 실패하든), ApiFuture가 지정된 Executor(스레드)를 사용해 listener(콜백 코드)를 자동으로 실행시켜 준다.


실제 사용 코드

    //채팅방 생성
    public ConversationRoom createRoom(String userId) {

        // 네트워크 통신을 하지 않는다 (DB에 요청x)
        //Firestore 클라이언트 라이브러리(SDK)가 자체적으로 고유한 20자리 랜덤 ID를 생성한다.
        // 이 ID를 가진 빈 껍데기 주소, 즉 DocumentReference 객체를 만든다.
        DocumentReference docRef = db.collection("ROOMS").document();

        ConversationRoom room = new ConversationRoom();
        room.setTitle("새로운 대화");
        room.setUserId(userId);
        
        //@ServerTimestamp를 통해서 Firestore가 문서를 쓸 때 자동으로 현재 서버 시간을 해당 필드에 기록
        room.setLastMessageAt(null);
        room.setId(docRef.getId()); //확보된 ID를 객체에 설정

        try {
            // Firestore에 데이터를 쓰는 것은 네트워크를 통해 다른 서버에 요청하는 것
            // ApiFuture은 비동기적으로 작업 요청을 한 후 나중에 완료되면 결과를 담음
            // 실제 DB쓰기는 백그라운드 스레드에서 시작
            ApiFuture&lt;WriteResult&gt; future = docRef.set(room);

            // 쓰기가 완료될 때까지 여기서 대기(Blocking)
            future.get(); //이 시점에 InterruptedException 또는 ExecutionException

            // DB쓰기 성공이 확정된 후에 객체를 반환
            return room;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // 인터럽트 복원
            throw new RuntimeException("채팅방 생성 실패(인터럽트)", e);
        } catch (ExecutionException e) {
            // .get() 실행 중 Firestore 쓰기 실패 (권한, 네트워크 등)
            throw new RuntimeException("채팅방 생성 실패", e);
        }

    }



1. ApiFuture와 비동기 작업의 시작

ApiFuture&lt;WriteResult&gt; future = docRef.set(room);



  메인 스레드 (A):
여기서 “메인 스레드”는 단일 프로그램의 UI 스레드가 아니라, 단순히 createRoom 메서드를 실행하고 있는 요청 처리 스레드를 의미한다.
    
      docRef.set(room) 메서드를 호출
      Firestore SDK는 이 요청(room 객체 저장)을 즉시 내부 작업 큐에 등록한다.
      그리고 실제 네트워크 작업을 수행할 다른 스레드에게 위임한다.
      위임 직후, ApiFuture라는 Promise 객체를 즉시 반환한다.
      이 시점에서 ‘메인 스레드’는 멈추지 않고 바로 다음 줄(future.get())로 이동한다.
    
  
  
    Firestore I/O 스레드 (B):

    
      Firestore SDK는 gRPC 클라이언트/Executor를 내부적으로 가지고 있고,
애플리케이션 스레드(A)에서 넘긴 작업을 이 Executor(스레드 풀)에서 처리한다.
그래서 애플리케이션 입장에서는 ApiFuture만 받고,
실제 네트워크 I/O는 SDK의 별도 스레드에서 수행된다.

      
        (A) 스레드로터 위임받은 ‘room 객체 저장’ 작업을 실제로 수행한다.
        데이터를 직렬화하고, 네트워크를 통해 Firestore 서버와 통신을 시작한다.
        이 작업은 (A) 스레드의 작업과 동시에(비동기) 일어난다.
      
    
  




2. future.get() - 스레드의 강제 대기 (Blocking)

future.get(); //이 시점에 InterruptedException 또는 ExecutionException



  메인 스레드 (A): future.get()을 만나는 순간, 실행을 멈추고 ‘대기(Waiting/Blocked)’ 상태가 된다.
  (A) 스레드는 future가 ‘완료’ 상태가 될 때까지 아무것도 하지 않고 기다린다.
  Firestore I/O 스레드 (B): 한편, (B) 스레드는 여전히 네트워크 통신을 하고 있다.
    
      성공 시: (B) 스레드가 서버로부터 “저장 성공!” 응답을 받으면, future 객체에 WriteResult를 넣어주고 ‘완료’ 상태로 만든다.
      실패 시: (B) 스레드가 서버로부터 에러(예: 권한 없음)를 받으면, future 객체에 Exception 정보를 넣어주고 ‘완료(실패)’ 상태로 만든다.
    
  
  future의 상태가 ‘완료’가 되는 순간, 대기 중이던 메인 스레드 (A)가 깨어난다(Unblocked).


이 get() 호출 때문에, 비동기 작업이 끝날 때까지 동기 방식처럼 기다리게 된다.



3. 예외 처리와 스레드

1) ExecutionException (작업 자체의 실패)


  발생 주체: Firestore I/O 스레드 (B)
  상황: (B) 스레드가 Firestore 서버와 통신하다가 실패했다. (네트워크 오류, 서버 다운, 쓰기 권한 없음 등)
  동작: (B) 스레드가 이 실패 정보를 future 객체에 등록한다.
  결과: 대기 중이던 메인 스레드 (A)가 깨어나고, future.get()은 ExecutionException을 (A) 스레드에게 던진다.
  e.getCause()를 호출하면 (B) 스레드가 겪었던 실제 원인(예: FirestoreException)을 알 수 있다.


2) InterruptedException (작업 대기 중 방해)


  발생 주체: 제 3의 스레드 (C) (메인 스레드도, I/O 스레드도 아닌)
  상황: 메인 스레드 (A)가 future.get()에서 대기하고 있다. 이때 (C) 스레드가 (A) 스레드를 깨우기 위해 (A스레드).interrupt() 신호를 보낸다. (예: 웹 서버가 종료될 때 요청 처리 스레드를 강제 종료시킬 경우)
  동작: (A) 스레드는 작업을 기다리던 것을 중단하고 즉시 깨어난다.
  결과: future.get()은 InterruptedException을 (A) 스레드에게 던진다.
  중요 포인트 1: 이건 Firestore 작업 실패와 무관할 수 있다. 단지 A의 ‘대기’가 끊겼다는 뜻이다. 백그라운드 작업(B)은 여전히 돌고 있을 수 있다.
  중요 포인트 2: InterruptedException이 던져지는 시점에 현재 스레드의 interrupt flag는 클리어되기 때문에, 관례상 catch 안에서 Thread.currentThread().interrupt()로 다시 설정한 뒤 상위로 전달하거나 적절히 중단 처리해야 한다.




ApiFutures


  유틸리티 클래스
  이 클래스 안에는 ApiFuture 객체를 더 쉽게 다룰 수 있게 도와주는 static 메서드들이 들어 있다.
  핵심 기능: ApiFutures.addCallback(future, callback, executor)
    
      ApiFuture 객체를 받아서 “이 작업이 성공하면 이 코드를 실행하고, 실패하면 저 코드를 실행해 줘”라는 콜백을 등록할 수 있다.
    
  


ApiFutures.addCallback(future, callback, executor)

  public static &lt;V&gt; void addCallback(
      final ApiFuture&lt;V&gt; future, final ApiFutureCallback&lt;? super V&gt; callback, Executor executor) {
    Futures.addCallback(
        listenableFutureForApiFuture(future),
        new FutureCallback&lt;V&gt;() {
          @Override
          public void onFailure(Throwable t) {
            callback.onFailure(t);
          }

          @Override
          public void onSuccess(V v) {
            callback.onSuccess(v);
          }
        },
        executor);
  }


1. listenableFutureForApiFuture(future)


  ApiFuture는 이미 ListenableFuture를 상속하고 있기 때문에,
listenableFutureForApiFuture는 대부분의 경우 캐스팅 또는 어댑터 역할을 한다.
결국 Guava Futures.addCallback을 쓰기 위해 ApiFuture를 ListenableFuture로 브릿지해준다



2. new FutureCallback&lt;V&gt;() { ... }


  ApiFutures.addCallback이 요구하는 콜백 타입은 FutureCallback 인터페이스이다.
  근데 우리가 파라미터로 받은 건 ApiFutureCallback 인터페이스이다.
  그래서 FutureCallback 익명 클래스를 즉석에서 만들어서, 그 내부에서 우리가 받은 ApiFutureCallback(변수명 callback)을 그대로 호출해주는 것이다.
  onFailure가 오면 callback.onFailure를, onSuccess가 오면 callback.onSuccess를 부르는 전달자 역할을 한다.


3. Executor executor

Executor는 콜백(onSuccess/onFailure)을 어떤 스레드에서 실행할지를 결정하는 규칙이다.


  MoreExecutors.directExecutor()
    
      동작: 즉시 실행
      별도의 스레드를 사용하지 않는다. ApiFuture의 비동기 작업(예: Firestore I/O)을 완료시킨 바로 그 스레드가, 콜백을 즉시 직접 실행한다.
      언제 쓰는가?
    
    
      스레드를 갈아타는 비용이 없어서 성능이 가장 좋다.
      콜백 로직이 아주 가볍고, 절대 블로킹 되지 않을 때 쓴다.
    
  
  스레드 풀 (예: Executors.newFixedThreadPool(nThreads), Executors.newCachedThreadPool() )
    
      동작: 작업 위임
      ApiFuture 가 완료되면, 콜백 로직(Runnable)을 이 스레드 풀에 작업으로 제출(submit)한다.
    
  


그럼 풀에 대기 중인 워커 스레드 중 하나가 그 콜백을 실행한다.


  언제 쓰는가?
    
      콜백안에서 시간이 걸리는 작업을 해야 할 때 쓴다.
      예를 들어, DB에서 읽은 결과로 다시 파일을 쓰거나, 다른 네트워크 요청을 보내는 등 무겁거나 블로킹되는 작업을 할 때 쓴다.
      이렇게 하면, ApiFuture를 완료시켰던 I/O 스레드는 무거운 콜백 처리를 워커 스레드에게 넘기고, 자기는 즉시 다른 I/O 작업을 하러 갈 수 있어서 효율적이다.
    
  




실제 사용 코드

/**
 * Firestore에 질문/답변 한 쌍을 하나의 메시지로 저장하고,
 * 저장된 결과를 다시 읽어와 ConversationMessage로 반환하는 메서드.
 *
 * 핵심 포인트:
 * - Firestore의 ApiFuture를 Reactor의 Mono로 감싸서 리액티브하게 사용
 * - set(쓰기) → get(읽기)를 체이닝
 * - timeout, retry, onErrorResume로 실패 시 복구 전략 정의
 */
public Mono&lt;ConversationMessage&gt; createMessage(String question, String answer, String roomId) {

    // 1. Firestore 컬렉션/문서 경로 구성
    //    - ROOM 컬렉션 아래에 각 방(roomId) 문서가 있고,
    //    - 그 아래 MESSAGES 서브컬렉션에 메시지 문서가 쌓인다고 가정.
    DocumentReference ref = db
            .collection(ROOMS)
            .document(String.valueOf(roomId))
            .collection(MESSAGES)
            .document(); // 여기서 Firestore가 새 문서 ID를 랜덤으로 생성해 줌

    // 2. 우선 애플리케이션 레벨에서 사용할 메시지 객체 하나를 만들어 둔다.
    //    - Firestore에서 toObject() 실패/타임아웃이 나도 이 객체를 fallback으로 쓸 수 있게 하기 위함.
    String messageId = ref.getId();
    ConversationMessage message = ConversationMessage.builder()
            .question(question)
            .answer(answer)
            .id(messageId)   // Firestore에서 생성한 문서 ID를 그대로 사용
            .roomId(roomId)
            .build();

    // 3. Firestore에 message를 쓰는 비동기 작업을 Mono로 감싸기
    //    - ref.set(message)는 ApiFuture&lt;WriteResult&gt;를 반환한다.
    //    - ApiFutures.addCallback으로 완료 콜백을 등록하고,
    //      그 콜백 안에서 Reactor의 sink.success / sink.error를 호출해 Mono를 완료시킨다.
    Mono&lt;WriteResult&gt; setMono = Mono.create(sink -&gt; {
        ApiFutures.addCallback(
                ref.set(message),                          // 비동기 쓰기 작업 시작
                new ApiFutureCallback&lt;WriteResult&gt;() {     // 작업 완료 시 호출될 콜백

                    @Override
                    public void onFailure(Throwable t) {
                        // Firestore 쓰기 실패 → Mono 에러로 전달
                        sink.error(t);
                    }

                    @Override
                    public void onSuccess(WriteResult wr) {
                        // Firestore 쓰기 성공 → Mono 정상 완료
                        sink.success(wr);
                    }

                },
                // 콜백을 별도 스레드 풀로 보내지 않고,
                // Firestore I/O 스레드에서 바로 실행하도록 하는 Executor.
                // 콜백 내부가 가볍기 때문에 directExecutor로 스레드 전환 비용을 줄인다.
                MoreExecutors.directExecutor()
        );
    });

    // 4. 방금 쓴 문서를 다시 읽어오는 비동기 작업을 Mono로 감싸기
    //    - ref.get() 역시 ApiFuture&lt;DocumentSnapshot&gt;를 반환.
    //    - 패턴은 setMono와 동일하게 ApiFutures.addCallback + Mono.create 사용.
    Mono&lt;DocumentSnapshot&gt; getMono = Mono.create(sink -&gt; {
        ApiFutures.addCallback(
                ref.get(),                                     // 비동기 읽기 작업 시작
                new ApiFutureCallback&lt;DocumentSnapshot&gt;() {    // 완료 콜백

                    @Override
                    public void onFailure(Throwable t) {
                        // 읽기 실패 → Mono 에러
                        sink.error(t);
                    }

                    @Override
                    public void onSuccess(DocumentSnapshot snap) {
                        // 읽기 성공 → DocumentSnapshot 전달
                        sink.success(snap);
                    }

                },
                MoreExecutors.directExecutor()
        );
    });

    // 5. 리액티브 파이프라인 구성
    return setMono                  // (1) 먼저 쓰기 작업을 수행하고
            .then(getMono)          // (2) 쓰기가 끝나면 이어서 읽기 작업 실행
            .map(snap -&gt; {          // (3) 읽어온 DocumentSnapshot을 도메인 객체로 변환

                // 문서가 존재하지 않으면(이상 상황) fallback으로 처음 만든 message 반환
                if (!snap.exists()) return message;

                // Firestore가 저장한 JSON → ConversationMessage로 역직렬화
                ConversationMessage cm = snap.toObject(ConversationMessage.class);

                // 역직렬화에 실패하면 역시 fallback 객체 사용
                if (cm == null) return message;

                // Firestore에서 읽어온 엔티티에 ID/roomId를 다시 한 번 확실히 세팅
                cm.setId(snap.getId());
                cm.setRoomId(roomId);

                return cm;
            })
            // (4) 전체 파이프라인에 5초 타임아웃 적용
            //     5초 안에 쓰기+읽기가 끝나지 않으면 TimeoutException 발생
            .timeout(java.time.Duration.ofSeconds(5))
            // (5) 그래도 실패하면(모든 재시도/타임아웃/기타 에러) 최종 fallback 전략:
            //     - 에러를 호출자에게 그대로 전달하지 않고,
            //     - 처음에 만들어 두었던 message 객체를 그대로 반환한다.
            //     → UI 입장에서는 "일단 메시지는 생성된 것처럼" 동작하게 된다.
            .onErrorResume(e -&gt; Mono.just(message));
            //이 경우 실제 Firestore에 저장이 안 되었을 수도 있으므로, 
            //운영 환경에서는 별도의 로그/알람으로 실패 케이스를 추적하고, 
            //필요하다면 재처리 배치를 두는 등 데이터 정합성을 보완해줄 필요가 있다.
}





마무리 요약


  Firestore Java SDK의 ApiFuture&lt;V&gt;는 Future&lt;V&gt; → ListenableFuture&lt;V&gt;를 확장한 형태로, 비동기 작업의 결과를 표현하는 핸들이다.
  get()을 호출하면 여전히 호출한 스레드는 블로킹되지만, addListener나 ApiFutures.addCallback을 사용하면 콜백 기반으로 결과를 처리할 수 있어 스레드를 막지 않고 비동기 체인을 만들 수 있다.
  Firestore 연산(docRef.set, docRef.get)은 내부적으로 별도 I/O 스레드 풀에서 네트워크 작업을 수행하고, 그 완료 여부와 결과를 ApiFuture 객체에 기록한다.
  ExecutionException은 비동기 작업에서 발생한 예외를 future.get()을 호출한 스레드로 전달하기 위한 래퍼 예외이고, 실제 원인은 getCause()로 확인할 수 있다.
  InterruptedException은 결과를 기다리던 스레드가 외부에서 인터럽트됐다는 신호이며, 관례적으로 catch 블록에서 Thread.currentThread().interrupt()를 호출해 인터럽트 상태를 복구해 주어야 한다.
  ApiFuture를 Reactor의 Mono로 감싸면, timeout, retry, onErrorResume 등을 조합해 재시도/타임아웃/폴백 전략을 코드 상에서 명시적으로 설계할 수 있다. 이때 재시도에 따른 중복 쓰기, 폴백 시 데이터 정합성 등은 의도적으로 선택한 트레이드오프임을 인지하고 설계해야 한다.


                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2025-10-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/java-thread-start-part5-thread-lifecycle-summary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/thread-start.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/java-thread-start-part5-thread-lifecycle-summary.html"><h1 class="title_post">[Java Multithreading] 마지막 글 - 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태</h1></a>
                        <a href="/Java/java-thread-start-part5-thread-lifecycle-summary.html" class="txt_post">
                            [Java Multithreading] 마지막 글 - 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태

시리즈 전체 보기


  Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교
  Part 2 – Thread.start() 뒤에서 일어나는 일: start0() ~ JVM_StartThread ~ JavaThread
  Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()
  Part 4 – 새로운 스레드가 자바 run()에 도달하기까지:  thread_native_entry → JavaThread::run → thread_entry → Thread.run()
  마지막 글 – 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태


앞선 글에서:


  Part 1: run() vs start() – 왜 결과가 다른지 (OS 스레드 생성 유무)
  Part 2: start() 뒤에서 벌어지는 일 – start0() → JVM_StartThread → JavaThread
  Part 3: OS 스레드 생성 과정 – os::create_thread → pthread_create → glibc → clone()
  Part 4: 새 스레드가 자바 run()까지 올라오기 – thread_native_entry → JavaThread::run → thread_entry → Thread.run()


까지 상세히 따라갔다.

이 마지막 글에서는 큰 그림을 한 번에 정리한다.


  자바에서 new Thread(...).start()를 호출하는 순간부터
  OS 커널이 스레드를 만들고
  JVM이 초기화하고
  자바 run()이 실행되고
  스레드가 종료되어 TERMINATED 상태로 남을 때까지


를 단일 다이어그램 + 단계별 요약으로 정리해보자.



1. 한 장으로 보는 전체 다이어그램

먼저, 전체 흐름을 위에서 아래로 쭉 그려보면 이렇게 된다.

[Java 코드 영역]
  A1  new Thread(runnable)
      └─ 자바 힙에 Thread 객체만 생성 (OS 스레드는 아직 없음)
          ↓
  A2  thread.start() 호출
          ↓
  A3  Thread.start() 자바 메서드
      └─ synchronized(this)로 this(Thread 객체) 모니터 락 획득
      └─ 상태 검사: 이미 시작된 스레드면 IllegalThreadStateException
          ↓
  A4  native 메서드 start0() 호출
      └─ 자바 → 네이티브 코드(JNI)로 진입

───────────────────────────────────────────────────────────────

[JVM 네이티브 (HotSpot C++) 영역]
  B1  JVM_StartThread(env, jthread)
      └─ JNI로 연결된 C++ 함수
      └─ jthread = 자바의 java.lang.Thread 인스턴스
          ↓
  B2  새 JavaThread 생성
      └─ new JavaThread(thread_entry, stackSize)
      └─ HotSpot 내부에서 자바 스레드를 표현하는 C++ 객체
      └─ entry_point = thread_entry 로 설정
          ↓
  B3  JavaThread.prepare(jthread)
      └─ JavaThread ↔ java.lang.Thread 연결
         - JavaThread 내부에 자바 Thread 객체 핸들 저장
         - 자바 Thread 쪽에도 native thread 포인터 연결
          ↓
  B4  os::create_thread(JavaThread*, threadType, stackSize) 호출
      └─ 플랫폼 의존 OS 스레드 생성 함수로 위임
      └─ threadType = java_thread / compiler_thread 등
          ↓
  B5  Threads_lock 잡고 JVM 스레드 목록에 등록 준비
      └─ JVM 전역 스레드 리스트에 추가하기 위한 동기화

───────────────────────────────────────────────────────────────

[OS / glibc / 커널 영역]
  C1  os::create_thread 내부에서 pthread_create 호출 (Linux 기준)
      └─ OSThread 객체 생성 후 JavaThread에 연결
      └─ pthread_attr 설정 (detach, stack size, guard page 등)
          ↓
  C2  glibc pthread_create → clone() 시스템 콜
      └─ 유저 공간(glibc)에서 커널 clone() 호출
          ↓
  C3  Linux 커널이 task_struct 생성
      └─ 새 스레드용 task_struct 생성
      └─ 스케줄러에 새 스레드 등록 (Runnable 상태에 올림)
          ↓
  C4  새 OS 스레드의 시작 루틴 실행
      └─ thread_native_entry(Thread*) 함수부터 실행 시작
      └─ 인자로 JavaThread* 포인터를 전달받음

───────────────────────────────────────────────────────────────

[새 OS 스레드 초기화 (thread_native_entry)]
  D1  스택 베이스/크기 기록
      └─ stack base / stack size를 기록해서
         - 스택 오버플로 감지
         - 스택 워킹, 샘플링, GC 등에 사용
          ↓
  D2  TLS, 시그널 마스크, FPU 상태 등 초기화
      └─ Thread::initialize_thread_current()
      └─ current thread 바인딩, NUMA, 시그널 마스크, FPU 상태 설정
          ↓
  D3  OSThread 상태를 INITIALIZED 로 설정
      └─ "OS 스레드 생성 완료, 아직 본격 실행 전" 상태
          ↓
  D4  startThread_lock 모니터에서 부모와 핸드셰이크
      └─ 부모에게 INITIALIZED 상태를 알리고 notify_all
      └─ 그 다음, osthread-&gt;state == INITIALIZED 인 동안 wait
      └─ 즉, 부모가 "이제 달려도 된다" 신호 줄 때까지 대기
          ↓
  D5  부모가 상태를 RUNNABLE 로 바꾸고 notify → wait 탈출
      └─ 부모 스레드: os::start_thread → pd_start_thread
      └─ RUNNABLE로 변경 + startThread_lock.notify()
      └─ 자식 스레드: wait_without_safepoint_check()에서 깨어남
          ↓
  D6  thread-&gt;call_run() 호출
      └─ 가상 디스패치로 JavaThread::run() 실행

───────────────────────────────────────────────────────────────

[JavaThread 런타임 (run → thread_main_inner → entry_point)]
  E1  JavaThread::run()
      └─ 새 자바 스레드의 VM 내부 런루틴 시작점
          ↓
  E2  TLAB 초기화 / 스택 가드 / JFR·JVMTI 훅 등록
      └─ TLAB(Thread-Local Allocation Buffer) 준비
      └─ 스택 가드 페이지 설치 (스택 오버플로 감지)
      └─ JFR, JVMTI, DTrace에 thread-start 이벤트 알림
          ↓
  E3  thread_main_inner() 호출
      └─ 실제 자바 엔트리 포인트 실행을 담당하는 내부 함수
      └─ _threadObj(자바 Thread 객체 핸들) 확인
      └─ pending exception 없으면 entry_point 호출
          ↓
  E4  entry_point(this, this) 호출
      └─ 일반 JavaThread 의 경우 entry_point = thread_entry
      └─ 결국 thread_entry(JavaThread*, TRAPS)로 진입

───────────────────────────────────────────────────────────────

[자바 Thread.run() 호출 (thread_entry)]
  F1  thread_entry(JavaThread*, THREAD)
      └─ 자바 스레드 실행의 진짜 "시작점" 역할
      └─ TRAPS = 예외 컨텍스트 (JavaThread* THREAD로 확장)
          ↓
  F2  thread-&gt;threadObj() 로 java.lang.Thread 핸들 획득
      └─ 이 JavaThread와 매핑된 자바 Thread 객체(oop)를 Handle로 감싸 GC-safe하게 참조
          ↓
  F3  JavaCalls.call_virtual(..., "run", "()V") 호출
      └─ 수신자: Thread 인스턴스
      └─ 메서드: run, 시그니처: ()V
      └─ 가상 호출이기 때문에
         - Thread 서브클래스가 run() 오버라이드했다면 그 구현 실행
         - 아니면 기본 Thread.run() 실행
      └─ VM 상태를 _thread_in_Java로 전환하고 자바 코드로 점프
          ↓
  F4  자바 Thread.run() 안에서 Runnable.run() 실행
      └─ 기본 구현:
           public void run() {
             if (target != null) {
               target.run();
             }
           }
      └─ 익명 Runnable, 람다 등이 여기서 실제로 실행됨

───────────────────────────────────────────────────────────────

[스레드 종료 이후 처리]
  G1  run() 정상 종료 또는 예외 발생
      └─ 정상 종료: 스택을 타고 빠져나오며 thread_entry → JavaThread::thread_main_inner → JavaThread::run() 종료
      └─ 예외: pending exception으로 잡혀서
         - ThreadGroup의 uncaughtException 등으로 전달될 수 있음
          ↓
  G2  OS 스레드 종료
      └─ thread_native_entry 마지막에서 return
      └─ 커널 task_struct 정리, 스케줄러에서 제거
          ↓
  G3  JVM: JavaThread / OSThread 정리
      └─ Threads 리스트에서 제거
      └─ JVM 내부 구조체(JavaThread, OSThread) 리소스 해제
          ↓
  G4  자바 Thread 객체는 힙에 남아 있음
      └─ GC 대상이 되기 전까지 살아 있고
      └─ thread.getState() → TERMINATED 로 보임
      └─ 즉, "껍데기(자바 객체)는 남고, OS 스레드는 사라진 상태"



이제 이 큰 그림을 스레드 “상태”와 함께 단계별로 다시 정리해보자.



2. 스레드 라이프사이클 – 상태(state) 기준으로 다시 보기

2-1. NEW – 단순히 객체만 있는 상태

자바 코드:

Thread t = new Thread(runnable);


이 시점에는:


  힙에 Thread 객체 하나만 있을 뿐,
  OS 스레드도 없고,
  JVM 내부의 JavaThread/OSThread도 없다.
  Thread.getState()는 NEW.


즉, 그냥 “미래에 스레드가 될 수도 있는 자바 객체”만 있는 상태다.



2-2. start() 호출 직후 – 자바 메서드 → 네이티브 진입

t.start();


내부적으로:


  Thread.start() 자바 메서드가 호출되고
    
      synchronized(this)로 중복 시작 방지
      holder.threadStatus를 보고 이미 시작된 스레드면 IllegalThreadStateException 던짐
    
  
  상태 체크를 통과하면 start0() 호출


public void start() {
    synchronized (this) {
        if (holder.threadStatus != 0)
            throw new IllegalThreadStateException();
        start0();  // native
    }
}



여기서부터는 자바 코드가 아닌 JVM 네이티브 코드로 내려간다.



2-3. start0() → JVM_StartThread – JavaThread/OSThread 생성

start0()는 native 메서드이기 때문에, 앞에서 본 registerNatives()에 의해 JVM_StartThread와 매핑된다.

JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
  JavaThread* native_thread = nullptr;
  bool throw_illegal_thread_state = false;

  {
    MutexLocker ml(Threads_lock);

    if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != nullptr) {
      throw_illegal_thread_state = true;
    } else {
      jlong size = java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
      size_t sz = size &gt; 0 ? (size_t)size : 0;

      native_thread = new JavaThread(&amp;thread_entry, sz);

      if (native_thread-&gt;osthread() != nullptr) {
        native_thread-&gt;prepare(jthread); // 자바 Thread 객체와 연결
      }
    }
  }

  if (throw_illegal_thread_state) {
    THROW(vmSymbols::java_lang_IllegalThreadStateException());
  }
  if (native_thread-&gt;osthread() == nullptr) {
    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), "Failed to create native thread");
  }

  Thread::start(native_thread);
JVM_END



여기서:


  JavaThread: JVM이 관리하는 C++ 스레드 객체
  OSThread: OS 스레드 핸들을 캡슐화한 객체
  prepare(jthread)로 JavaThread ↔ 자바 Thread 객체를 연결해 둔다.
  마지막에 Thread::start(native_thread)에서 실제 실행을 허용하는 플래그를 바꾸게 된다.




2-4. OS 레벨 – os::create_thread → pthread_create → clone()

JavaThread 생성자 내부에서는 os::create_thread로 넘어간다.

JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MemTag mem_tag)
  : JavaThread(mem_tag) {
  set_entry_point(entry_point);

  os::ThreadType thr_type = os::java_thread;
  thr_type = entry_point == &amp;CompilerThread::thread_entry
             ? os::compiler_thread
             : os::java_thread;

  os::create_thread(this, thr_type, stack_sz);
}



os::create_thread (Linux 기준):


  OSThread 할당, 상태 ALLOCATED
  pthread_attr 설정 (detach, stack size, guard size)
  pthread_create(&amp;tid, &amp;attr, thread_native_entry, thread) 호출
  자식이 INITIALIZED로 바꿀 때까지 startThread_lock 모니터에서 대기


pthread_create → glibc 내부:


  내부에서 clone() 시스템콜 호출
  커널이 새 task_struct를 만들고 실행 큐에 넣음
  새 OS 스레드가 thread_native_entry를 실행하기 시작


이 시점에서:


  OS 기준: 새로운 실행 흐름(스레드)이 실제로 생성됨.
  JVM 기준: 이 OS 스레드는 HotSpot 관리 코드(thread_native_entry) 안으로 들어온 상태.




2-5. 새 스레드 초기화 + start barrier – INITIALIZED → RUNNABLE

자식 스레드는 thread_native_entry(thread)로 들어와서:


  스택/시그널/TLS/FPU 등 환경 초기화
  startThread_lock 모니터에서 상태를 INITIALIZED로 바꾸고 부모에게 notify
  부모가 상태를 RUNNABLE로 바꾸고 notify를 줄 때까지 wait()


부모는:


  JVM_StartThread 마지막에 Thread::start(native_thread) 호출
  Thread::start 안에서:
    
      자바 Thread 객체 상태를 RUNNABLE로
      os::start_thread(native_thread) 호출
    
  
  os::start_thread:
    
      OSThread 상태를 RUNNABLE로
      pd_start_thread에서 startThread_lock-&gt;notify() 호출
    
  


결국:


  자식은 while (state == INITIALIZED) 루프를 빠져나오고
  마침내 thread-&gt;call_run()으로 넘어간다.




2-6. JVM 내부 run 루틴 – JavaThread::run → thread_main_inner → entry_point

thread-&gt;call_run()은 JavaThread::run()을 호출한다.

JavaThread::run():


  TLAB, stack guard, JFR/JVMTI, JNI 핸들 블록 등 자바 스레드를 위한 VM 환경을 세팅
  마지막에 thread_main_inner() 호출


thread_main_inner():


  _threadObj(자바 Thread 인스턴스) 확인
  pending exception이 없으면 entry_point(this, this) 호출
  일반 자바 스레드의 경우 entry_point == thread_entry



  즉, 여기서 드디어 thread_entry(JavaThread*, TRAPS)가 호출된다.




2-7. thread_entry – Thread.run()을 실제로 호출하는 지점

static void thread_entry(JavaThread* thread, TRAPS) {
  HandleMark hm(THREAD);
  Handle obj(THREAD, thread-&gt;threadObj());
  JavaValue result(T_VOID);

  JavaCalls::call_virtual(&amp;result,
                          obj,
                          vmClasses::Thread_klass(),
                          vmSymbols::run_method_name(),
                          vmSymbols::void_method_signature(),
                          THREAD);
}



이 코드가 하는 일:


  thread-&gt;threadObj()로 자바 Thread 객체 핸들 확보
  JavaCalls::call_virtual(..., "run", "()V") 호출
    
      가상 메서드 해석 (오버라이드된 run()이면 그걸 호출)
      스레드 상태 _thread_in_vm → _thread_in_Java 전환
      인터프리터 or JIT 코드로 진입
      예외 발생 시 THREAD에 pending exception으로 기록
    
  


최종적으로 실행되는 건 자바 코드:

class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("MyThread run");
    }
}

Thread t = new MyThread();
t.start();




2-8. run() 종료 이후 – OS 스레드는 사라지지만, Thread 객체는 남는다

run()이 끝나면:


  OS 스레드는 커널에서 종료 처리되고, task_struct는 정리된다.
  JVM은 JavaThread/OSThread를 Threads 리스트에서 제거하고 내부 리소스를 정리한다.
  하지만 자바의 Thread 객체는 힙에 남아 있다.
    
      이 객체는 GC 대상이 될 때까지 계속 존재할 수 있고
      thread.getState()를 호출하면 TERMINATED를 반환한다.
      따라서 join() 같은 메서드에서 “이 스레드가 끝났는지” 여부를 확인할 수 있다.
    
  



  그래서, 실행 단위(실제 OS 스레드)는 사라져도, 자바의 Thread 인스턴스라는 “껍데기”는 남아서 상태를 알려주는 역할을 한다.





3. run() vs start() – 이제 완전히 명확하게

이제 전체 그림을 봤으니 한 줄로 정리할 수 있다.


  run()을 직접 호출하면:
    
      JVM은 OS 스레드, JavaThread, OSThread 아무 것도 만들지 않는다.
      그냥 현재 스레드에서 메서드 하나를 호출하는 것이다.
    
  
  start()를 호출하면:
    
      start0() → JVM_StartThread → JavaThread/OSThread 생성
      os::create_thread → pthread_create → clone()으로 OS 스레드 생성
      새 OS 스레드에서 thread_native_entry → JavaThread::run → thread_entry → Thread.run()이 호출된다.
    
  



  따라서, start()는 “새로운 실행 흐름(새 OS 스레드) + 그 안에서 run() 실행”을 의미하고,

  run() 직접 호출은 “지금 스레드에서 메서드 한 번 호출”을 의미한다.



이 차이를 이해하는 순간, 자바 스레드를 진짜 OS 스레드 관점에서 볼 수 있게 된다.

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2025-10-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/java-thread-start-part4-thread-entry-to-run.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/thread-start.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/java-thread-start-part4-thread-entry-to-run.html"><h1 class="title_post">[Java Multithreading] Part 4 – 새로운 스레드가 자바 run()에 도달하기까지: thread_native_entry → JavaThread::run → thread_entry → Thread.run()</h1></a>
                        <a href="/Java/java-thread-start-part4-thread-entry-to-run.html" class="txt_post">
                            [Java Multithreading] Part 4 – 새로운 스레드가 자바 run()에 도달하기까지: thread_native_entry → JavaThread::run → thread_entry → Thread.run()

시리즈 전체 보기


  Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교
  Part 2 – Thread.start() 뒤에서 일어나는 일: start0() ~ JVM_StartThread ~ JavaThread
  Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()
  Part 4 – 새로운 스레드가 자바 run()에 도달하기까지:  thread_native_entry → JavaThread::run → thread_entry → Thread.run()
  마지막 글 – 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태


0. 이번 파트에서 볼 것

Part 3까지의 흐름은 여기까지였다:


  
    Thread.start()

    → start0() (native)

    → JVM_StartThread

    → new JavaThread(thread_entry, stackSize)

    → os::create_thread

    → pthread_create(..., thread_native_entry, thread)

    → OS 커널이 새 스레드를 만들고, 그 스레드가 thread_native_entry로 진입
  


이제 Part 4에서는:


  “새로 만들어진 OS 스레드가 어떻게 자바 코드인 Thread.run()까지 올라오는지”



를 따라간다.

구체적으로:


  thread_native_entry(Thread* thread)
  JavaThread::run()
  JavaThread::thread_main_inner()
  thread_entry(JavaThread*, TRAPS)
  최종적으로 자바의 Thread.run() 호출


까지를 쭉 따라가면서, 부모/자식 스레드 동기화, start barrier, Handle/예외 컨텍스트, run() 호출 과정을 정리한다.



1. 다시 출발점 정리: pthread_create 이후 상황

Part 3에서 os::create_thread는 아래 코드를 통해 OS 스레드를 만들었다:

// openjdk/jdk/src/hotspot/os/linux/os_linux.cpp
bool os::create_thread(Thread* thread, ThreadType thr_type, size_t req_stack_size) {
	...
	pthread_t tid;
	int ret = pthread_create(&amp;tid, &amp;attr,
	                         (void* (*)(void*)) thread_native_entry,
	                         thread);
	...
}


여기서 중요한 점:


  새로 만들어진 OS 스레드는
    
      바로 thread_native_entry 함수로 들어간다.
    
  
  네 번째 인자는 thread (보통 JavaThread*).
    
      즉, 새 스레드는 thread_native_entry(JavaThread*)를 실행하기 시작한다.
    
  


이제 자식 스레드 입장에서 남은 경로는:


  thread_native_entry(thread) 진입
  HotSpot 내부 초기화 + 부모와 start barrier 핸드셰이크
  thread-&gt;call_run() 호출
  JavaThread::run() → thread_main_inner()
  entry_point(= thread_entry) 호출
  thread_entry에서 Thread.run() 호출


이 순서를 하나씩 뜯어본다.



2. 부모 입장 마지막 단계: Thread::start → os::start_thread → pd_start_thread

먼저, 부모(기존 스레드) 입장에서 마무리 작업을 다시 보자.

JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
  JavaThread* native_thread = nullptr;
  ...
  ...
  // 실행 시작 → OS 스케줄러에 등록
  Thread::start(native_thread);
JVM_END


먼저 JVM_StartThread는 함수 마지막에 Thread::start(natvie_thread);를 실행한다.

// openjdk/src/hotspot/share/runtime/thread.cpp

void Thread::start(Thread* thread) {
  if (thread-&gt;is_Java_thread()) {
    // 자바 Thread 상태를 RUNNABLE로 세팅 (자바 관점의 상태)
    java_lang_Thread::set_thread_status(
        JavaThread::cast(thread)-&gt;threadObj(),
        JavaThreadStatus::RUNNABLE);
  }
  os::start_thread(thread);
}



Thread::start는 두 가지를 한다:


  자바 Thread 객체 상태를 RUNNABLE 로 바꾸고
  os::start_thread(thread)를 호출해서 플랫폼 의존 레이어에 “이제 진짜 실행 시작해도 됨”이라고 알린다.


2-1. os::start_thread(thread) – 공통 레이어

// openjdk/src/hotspot/share/runtime/os.cpp

void os::start_thread(Thread* thread) {
  OSThread* osthread = thread-&gt;osthread();
  osthread-&gt;set_state(RUNNABLE);
  pd_start_thread(thread);
}




  
    osthread = thread-&gt;osthread()

    → JavaThread와 연결된 OSThread를 가져온다.
  
  
    osthread-&gt;set_state(RUNNABLE);

    → JVM 내부에서 이 스레드는 이제 실행 가능한 상태라고 표시.
  
  
    pd_start_thread(thread);

    → OS별 구현으로 위임 (Linux라면 os_linux.cpp의 pd_start_thread).
  


2-2. os::pd_start_thread(thread) – Linux 버전

// openjdk/src/hotspot/os/linux/os_linux.cpp

void os::pd_start_thread(Thread* thread) {
  OSThread * osthread = thread-&gt;osthread();
  assert(osthread-&gt;get_state() != INITIALIZED, "just checking");
  Monitor* sync_with_child = osthread-&gt;startThread_lock();
  MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);
  sync_with_child-&gt;notify();
}


정리하면:


  기존에 있던 스레드가 새 스레드를 만들면:

  기존 스레드 = 부모, 새로 만들어진 스레드 = 자식



여기서 일어나는 핵심:


  startThread_lock() 모니터를 가져온다.
  MutexLocker로 잠금을 건다.
  notify()를 호출해서 자식 스레드를 깨운다.


즉,


  자식 스레드는 startThread_lock 모니터에서 wait() 중이고
  부모는 pd_start_thread에서 notify()로 깨운다.


이 부분은 부모/자식 start barrier 핸드셰이크의 “부모 쪽 신호”라고 보면 된다.



누가 부모고, 누가 자식인가?

JVM 입장에서:


  
    부모 스레드

    → new Thread(...).start() 를 호출한 쪽.

    → 이미 돌고 있던 자바 스레드(예: main), 이 스레드가 내부에서 JVM_StartThread → os::create_thread → pthread_create 를 호출해서 새 OS 스레드를 만든다.
  
  
    자식 스레드(child)

    → pthread_create 로 새로 만들어진 OS 스레드.

    → 시작 함수는 thread_native_entry(Thread* thread)이고, 이 안에서 JavaThread::run() → 최종적으로 자바 Thread.run() 을 호출하게 된다.
  




실제로는 두 번 핸드셰이크 한다.

조금 더 정확히 말하면, HotSpot은 부모–자식 사이에서 두 단계로 핸드셰이크를 한다.

1단계 – os::create_thread 안쪽 (Part 3에서 자세하게 다룸)


  부모가 pthread_create 호출
  자식 OS 스레드가 thread_native_entry에 들어온다.
  
    자식이 “나 초기화 끝났어(INITIALIZED)” 라고 부모에게 알리고(notify),

    부모는 그 신호를 받을 때까지 ALLOCATED 상태에서 wait()로 잠깐 기다린다.
  


2단계 – Thread::start(thread) / os::start_thread(thread)


  
    부모 쪽에서 “이제 진짜 실행 시작해도 돼”라는 시점을 잡고,

    os::start_thread(thread) → os::pd_start_thread(thread) 를 호출
  
  
    자식은 INITIALIZED 상태에서 또 한 번 wait() 중이고,

    부모가 여기서 notify() 를 날려주면 자식이 깨어나서 thread-&gt;call_run() 으로 들어간다.
  


os::pd_start_thread 코드는 바로 2단계 – 부모가 자식에게 이제 시작하라고 신호 보내는 부분이다.



3. 자식 스레드 입장: thread_native_entry 진입

이제부터는 새로 생성된 자식 OS 스레드 입장이다.

(부모가 pthread_create로 자식 스레드 생성 후 단계) (위에서 1단계)

static void *thread_native_entry(Thread *thread) {
  thread-&gt;record_stack_base_and_size();

#ifndef __GLIBC__
  // glibc가 아닌 환경에서 스택 상의 핫 프레임들이
  // 같은 캐시 라인을 계속 두드리는 현상을 줄이기 위한 random alloca trick
  static int counter = 0;
  int pid = os::current_process_id();
  int random = ((pid ^ counter++) &amp; 7) * 128;
  void *stackmem = alloca(random != 0 ? random : 1);
  *(char *)stackmem = 1;
#endif

  thread-&gt;initialize_thread_current();

  OSThread* osthread = thread-&gt;osthread();
  Monitor* sync = osthread-&gt;startThread_lock();

  osthread-&gt;set_thread_id(checked_cast&lt;pid_t&gt;(os::current_thread_id()));

  if (UseNUMA) {
    int lgrp_id = os::numa_get_group_id();
    if (lgrp_id != -1) {
      thread-&gt;set_lgrp_id(lgrp_id);
    }
  }

  PosixSignals::hotspot_sigmask(thread);
  os::Linux::init_thread_fpu_state();

  {
    MutexLocker ml(sync, Mutex::_no_safepoint_check_flag);

    osthread-&gt;set_state(INITIALIZED);
    sync-&gt;notify_all();

    while (osthread-&gt;get_state() == INITIALIZED) {
      sync-&gt;wait_without_safepoint_check();
    }
  }

  log_info(os, thread)("Thread is alive (tid: %zu, pthread id: %zu).",
    os::current_thread_id(), (uintx) pthread_self());

  assert(osthread-&gt;pthread_id() != 0, "pthread_id was not set as expected");

  if (DelayThreadStartALot) {
    os::naked_short_sleep(100);
  }

  thread-&gt;call_run();

  thread = nullptr;

  log_info(os, thread)("Thread finished (tid: %zu, pthread id: %zu).",
    os::current_thread_id(), (uintx) pthread_self());

  return nullptr;
}



3-1. 상단부 초기화 (자세히 안보고 넘어가도 된다.)


  
    record_stack_base_and_size()

    → 이 스레드 스택의 시작 주소와 크기를 기록한다.

    나중에 스택 오버플로 감지, 스택 워킹, 샘플링에서 사용된다.
  
  
    (glibc가 아닐 때) alloca로 약간 랜덤 크기 스택 메모리를 할당

    → 스택 프레임이 항상 같은 캐시 라인에만 몰려서 캐시 eviction이 심해지는 것을 줄이는 트릭.
  
  
    initialize_thread_current()

    → 이 OS 스레드와 Thread* 객체(보통 JavaThread*)를 TLS(Thread Local Storage)에 연결.

    이후 Thread::current() / JavaThread::current()로 자신을 찾을 수 있다.
  
  
    osthread-&gt;set_thread_id(...)

    → OS에서 보는 스레드 ID를 기록.
  
  NUMA 환경이면 NUMA 그룹 ID 설정.
  
    hotspot_sigmask(thread)

    → 이 스레드의 시그널 마스크를 HotSpot이 기대하는 패턴으로 초기화.
  
  
    init_thread_fpu_state()

    → FPU/벡터 레지스터 상태(라운딩 모드, 예외 마스크 등) 초기화.
  


여기까지는 “OS 스레드를 HotSpot 관리 하에 올려놓기 위한 준비 작업”이다.

3-2. (핵심) 부모와의 start barrier – INITIALIZED ↔ RUNNABLE 전환

{
  MutexLocker ml(sync, Mutex::_no_safepoint_check_flag);

  // 1) 자식: "나 INITIALIZED까지 왔어" 상태 알림
  osthread-&gt;set_state(INITIALIZED);
  sync-&gt;notify_all();

  // 2) 부모가 상태를 바꿔줄 때까지 기다리기
  while (osthread-&gt;get_state() == INITIALIZED) {
    sync-&gt;wait_without_safepoint_check();
  }
}



동작 순서를 정리하면:


  자식 스레드는 startThread_lock 모니터를 잠근다.
  자신의 상태를 INITIALIZED로 바꾸고 notify_all() 한다.
    
      이 알림은 부모가 os::create_thread에서 기다리던 루프를 깨우기 위한 것이다.
    
  
  이후 부모가 Thread::start → os::start_thread → pd_start_thread에서
    
      상태를 RUNNABLE 로 바꾸고
      같은 모니터에 대해 notify()를 쏠 때까지 wait()한다.
    
  


즉,


  INITIALIZED는 “OS 스레드는 만들어졌고, JVM에서 기본 초기화도 끝났지만 출발 신호는 아직”이란 뜻.
  
    부모가 osthread-&gt;set_state(RUNNABLE) + notify()를 해줘야

    while (state == INITIALIZED) 루프를 빠져나가고, 그 다음 코드로 진행할 수 있다.
  


여기서 부모/자식 역할 분리를 정리하면:


  부모:
    
      JVM_StartThread 안에서 new JavaThread + os::create_thread 호출
      자식이 INITIALIZED까지 왔다는 신호를 받고
      Thread::start → os::start_thread → pd_start_thread로 최종 “출발” 신호를 보냄
    
  
  자식:
    
      thread_native_entry 안에서 HotSpot 초기화
      자신의 상태를 INITIALIZED로 바꾸고 부모에 알림
      다시 부모의 “출발” 신호가 올 때까지 초기화 배리어에서 대기
    
  


3-3. 배리어 통과 후: thread-&gt;call_run() 호출

배리어를 통과하면:

thread-&gt;call_run();


이 한 줄이 각 스레드 타입별 run 루틴으로 들어가는 진입점이다.


  JavaThread라면 → JavaThread::run() 호출
  VMThread, WatcherThread 등 다른 종류면 각각의 run()이 호출


우리가 보는 건 일반 자바 스레드(JavaThread)이므로, JavaThread::run()으로 이어진다.



4. JavaThread::run() – 자바 스레드용 VM 내부 런타임 준비

// openjdk/jdk/src/hotspot/share/runtime/javaThread.cpp

void JavaThread::run() {
  initialize_tlab();
  _stack_overflow_state.create_stack_guard_pages();
  cache_global_variables();

  assert(this-&gt;thread_state() == _thread_new, "wrong thread state");
  set_thread_state(_thread_in_vm);

  OrderAccess::cross_modify_fence();

  assert(JavaThread::current() == this, "sanity check");
  assert(!Thread::current()-&gt;owns_locks(), "sanity check");

  JFR_ONLY(Jfr::on_thread_start(this);)
  DTRACE_THREAD_PROBE(start, this);

  set_active_handles(JNIHandleBlock::allocate_block());

  if (JvmtiExport::should_post_thread_life()) {
    JvmtiExport::post_thread_start(this);
  }

  if (AlwaysPreTouchStacks) {
    pretouch_stack();
  }

  thread_main_inner();
}



각 줄이 하는 일을 정리하면:  (자세히 안보고 넘어가도 된다.)


  
    initialize_tlab()

    → 이 스레드 전용 TLAB(Thread-Local Allocation Buffer)을 초기화한다.

    자바에서 new 할 때 글로벌 락 없이 자기 TLAB에서 빠르게 할당하기 위함.
  
  
    create_stack_guard_pages()

    → 스택 끝에 가드 페이지를 설치해 스택 오버플로를 감지한다.
  
  
    cache_global_variables()

    → 자주 쓰이는 전역 포인터/심볼 등을 스레드 로컬 캐시에 반영.
  
  
    set_thread_state(_thread_in_vm)

    → 이 스레드는 현재 “VM 코드 안에 있다”는 상태로 전환.
  
  
    cross_modify_fence()

    → 코드 패치/메모리 재배치 관련해서 강한 장벽을 쳐주는 부분.
  
  
    JFR/JVMTI/DTrace 관련 훅

    → 프로파일러/디버거/트레이싱 시스템을 위한 이벤트 발행.
  
  
    set_active_handles(...)

    → JNI 핸들 블록을 하나 열어, 네이티브에서 GC-safe oop 참조를 할 수 있게 한다.
  
  
    pretouch_stack() (옵션)

    → 스택 페이지를 미리 만져서 페이지 폴트 지연을 줄이는 기능.
  


그리고 마지막에: (핵심)

thread_main_inner();



→ 이제 “진짜로 이 자바 스레드가 무엇을 실행해야 하는지”로 들어가는 핵심 루틴이다.



5. JavaThread::thread_main_inner() – entry_point 호출 준비

void JavaThread::thread_main_inner() {
  assert(JavaThread::current() == this, "sanity check");
  assert(_threadObj.peek() != nullptr, "just checking");

  if (!this-&gt;has_pending_exception()) {
    {
      ResourceMark rm(this);
      this-&gt;set_native_thread_name(this-&gt;name());
    }
    HandleMark hm(this);

    this-&gt;entry_point()(this, this);
  }

  DTRACE_THREAD_PROBE(stop, this);
}



여기서 중요한 포인트는 세 가지다.

5-1. _threadObj 확인


  _threadObj는 이 JavaThread와 연결된 자바 java.lang.Thread 인스턴스에 대한 핸들이다.
  _threadObj.peek() != nullptr 체크로 “정상적으로 연결되어 있음”을 방어적으로 확인한다.


5-2. pending exception 여부 확인


  has_pending_exception() 가 false일 때만 엔트리 포인트를 호출한다.
  이유:
    
      JVMTI 등의 기능이 스레드 시작 전에 강제로 예외를 걸어둘 수 있다.
      그런 경우 run()을 호출하지 않고, 예외 처리 루틴으로 넘어가야 하기 때문.
    
  


5-3. entry_point 호출

this-&gt;entry_point()(this, this);



  
    entry_point는 JavaThread 생성 시 set_entry_point(thread_entry)로 설정해 두었던 함수 포인터.

      JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MemTag mem_tag) 
    : JavaThread(mem_tag) {
    set_entry_point(entry_point);
  	...
  }
    
    
  
  일반 자바 스레드의 경우 thread_entry(JavaThread*, TRAPS) 이다.
  인자를 (this, this) 두 개 넘기는 이유:
    
      첫 번째는 JavaThread* thread 자체
      두 번째는 TRAPS (보통 JavaThread* THREAD로 매크로 확장) = 예외 컨텍스트
    
  


즉, 여기서 드디어:


  thread_entry(this, this);



로 자바 Thread.run()을 호출하는 최종 C++ 함수로 진입한다.



6. thread_entry – JavaCalls::call_virtual로 Thread.run() 호출

static void thread_entry(JavaThread* thread, TRAPS) {
  HandleMark hm(THREAD);

  Handle obj(THREAD, thread-&gt;threadObj());

  JavaValue result(T_VOID);

  JavaCalls::call_virtual(&amp;result,
                          obj,
                          vmClasses::Thread_klass(),
                          vmSymbols::run_method_name(),
                          vmSymbols::void_method_signature(),
                          THREAD);
}


JavaCalls::call_virtual(...) (핵심)

JavaCalls::call_virtual(&amp;result,          // 반환값
                        obj,              // this (자바 Thread 인스턴스)
                        vmClasses::Thread_klass(),            // 선언 클래스
                        vmSymbols::run_method_name(),         // "run"
                        vmSymbols::void_method_signature(),   // "()V"
                        THREAD);          // 예외 컨텍스트



C++ 코드(JVM 내부)에서, 자바 객체 obj의 run() 메서드를 가상 메서드 호출 방식으로 실행하라는 의미이다.


  
    &amp;result

    → 자바 메서드의 반환값을 받아 둘 C++ 쪽 저장소.

    지금은 void라 사실상 의미 없음(그냥 형식상 필요).
  
  
    obj

    → this에 해당하는 자바 객체.

    여기서는 java.lang.Thread(또는 그 서브클래스) 인스턴스.
  
  
    vmClasses::Thread_klass()

    → “이 메서드가 어느 클래스에 선언되어 있다고 보고 찾을지”를 알려 줌.

    여기선 Thread 클래스 기준으로 run()을 찾는다는 의미.
  
  
    vmSymbols::run_method_name() / vmSymbols::void_method_signature()

    → 메서드 이름 "run" + 시그니처 "()V"

    → “인자 없고, void 리턴하는 run()”을 호출하겠다는 뜻.
  
  
    THREAD

    → 현재 JVM 스레드 컨텍스트(JavaThread*)에 대한 예외 처리 정보.

    자바 쪽에서 던진 예외를 여기(pending exception)로 기록해 둔다.
  


이 함수가 내부에서 하는 작업


  가상 메서드 해석 (어떤 run()을 호출할지 결정)


이거랑 똑같은 규칙을 적용해서 함수를 찾는다.


  선언 기준 클래스: Thread
  메서드 이름: "run"
  시그니처: "()V"


그래서:


  Thread 클래스에 선언된 run()을 기준으로 삼고,
  
    실제 obj의 실제 타입(서브클래스) 를 따라 올라가면서

    오버라이드된 run()이 있으면 그걸 호출한다.
  


예를 들어:

class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("MyThread run");
    }
}

Thread t = new MyThread();
t.start();


이 상황에서 obj가 MyThread 인스턴스라면,


  Thread.run() 이 아니라
  MyThread.run()이 실제로 실행되게 메서드를 찾아준다.


즉,


  “자바의 동적 디스패치(virtual call) 를 C++ 쪽에서 그대로 재현”



하는 단계라고 보면 된다.

b. 스레드 상태 전환


  _thread_in_vm → _thread_in_Java로 바꾸고
  인터프리터 / JIT 컴파일된 코드 중 적절한 곳으로 점프.


c.  예외 처리


  자바 run() 안에서 예외가 던져지면 C++ 예외로 바꾸지 않고
  THREAD에 pending exception으로 기록.
  
    호출이 끝난 뒤 상위 레벨에서 THREAD 상태를 보고

    uncaughtException 처리 등으로 넘긴다.
  


즉 , 이 지점 이후는 그냥 일반적인 자바 실행이다.

즉, JavaCalls::call_virtual은:


  “JVM 안에서, 특정 자바 객체의 가상 메서드를 한 번 호출해 주는 브리지”



역할을 한다.



                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2025-10-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/java-thread-start-part3-os-create-thread-pthread-glibc-clone.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/thread-start.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/java-thread-start-part3-os-create-thread-pthread-glibc-clone.html"><h1 class="title_post">[Java Multithreading] Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()</h1></a>
                        <a href="/Java/java-thread-start-part3-os-create-thread-pthread-glibc-clone.html" class="txt_post">
                            [Java Multithreading] Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()

시리즈 전체 보기


  Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교
  Part 2 – Thread.start() 뒤에서 일어나는 일: start0() ~ JVM_StartThread ~ JavaThread
  Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()
  Part 4 – 새로운 스레드가 자바 run()에 도달하기까지:  thread_native_entry → JavaThread::run → thread_entry → Thread.run()
  마지막 글 – 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태


0. 이번 파트에서 보는 것

Part 2에서 여기까지 내려왔다:


  Thread.start()

  → start0() (native)

  → JVM_StartThread

  → new JavaThread(thread_entry, stackSize)

  → Thread::start(native_thread) 호출 직전



이제 “JVM이 실제 OS 스레드를 어떻게 만드는지”를 따라갈 차례다.

이번 Part 3에서 다룰 범위는:


  JavaThread 생성자 안에서 호출되는 os::create_thread(...)
  OSThread 생성, pthread_attr 설정, pthread_create 호출
  그 아래에서 glibc가 clone() 시스템콜로 리눅스 커널에 스레드 생성 요청하는 흐름
  정리: HotSpot 레벨 ↔ glibc 레벨 ↔ 커널 레벨 세 층 구조


“새 스레드를 만든다”는 한 줄이

실제로는 세 겹을 타고 내려가는 일이라는 걸 보는 파트다.



1. Part 2 끝에서 우리는 어디까지 왔나?

Part 2 마지막 지점부터 다시 한 번 흐름을 짚어보면:

Thread.start()       // 자바
  → start0()         // native
    → JVM_StartThread(JNIEnv* env, jobject jthread)  // HotSpot C++
      → new JavaThread(&amp;thread_entry, stackSize)     // JVM 내부 스레드 객체 생성
      → JavaThread::prepare(jthread)                 // 자바 Thread와 연결
      → Thread::start(native_thread)                 // 실행 상태 전환 + OS 스레드 시작



오늘 보는 핵심은 이 줄 속에서:

native_thread = new JavaThread(&amp;thread_entry, sz);



이 한 줄이 실제로 OS 스레드를 어떻게 만드는지이다.



2. JavaThread 생성자: 여기서 os::create_thread(...)가 호출된다

HotSpot의 JavaThread 생성자는 대략 이런 구조다 (불필요한 부분을 많이 생략한 버전):

// openjdk/jdk/src/hotspot/share/runtime/javaThread.cpp

JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MemTag mem_tag)
  : JavaThread(mem_tag) {

  set_entry_point(entry_point); // 나중에 실행할 엔트리 포인트 (보통 thread_entry)

  // 어떤 타입의 스레드인지 결정
  os::ThreadType thr_type = os::java_thread;
  if (entry_point == &amp;CompilerThread::thread_entry) {
    thr_type = os::compiler_thread;
  } else {
    thr_type = os::java_thread;
  }

  // 실제 OS 스레드 생성 시도
  os::create_thread(this, thr_type, stack_sz);

  // 이 시점에서 _osthread는 null일 수도 있다 (리소스 부족 등)
  // 실패 여부 확인은 상위(JVM_StartThread)에서 한다.
}



2-1. ThreadFunction entry_point – 스레드가 살아나면 제일 먼저 들어갈 함수


  entry_point는 “이 스레드가 본격적으로 돌기 시작했을 때 호출할 함수 포인터”다.
  일반 자바 스레드의 경우 thread_entry가 들어온다.
    
      thread_entry(JavaThread*, TRAPS) 안에서 최종적으로 자바의 Thread.run()을 호출한다.
      thread_entry 자세한 내용은 Part 4에서 본다.
    
  


2-2. os::ThreadType – 스레드 종류(역할)에 따라 타입 분류

HotSpot은 스레드를 종류별로 구분한다:

enum ThreadType {
  java_thread,       // 일반 애플리케이션 자바 스레드 (new Thread())
  compiler_thread,   // JIT 컴파일러 전용 스레드
  vm_thread,         // VM 관리용 스레드
  gc_thread,         // GC 워커 스레드
  watcher_thread,    // WatcherThread (주기적 모니터링)
  os_thread          // 기타 OS 내부용 스레드
};




  우리가 new Thread(...).start()로 만드는 건 대부분 java_thread.
  JIT 컴파일러(C1/C2 등)용 스레드는 compiler_thread.
  GC, VM, Watcher 등도 각자 타입을 나눠 관리한다.


이 타입 정보는:


  스택 크기 기본값
  guard page 크기
  스케줄링/디버깅 옵션


등을 결정할 때 사용된다.

2-3. os::create_thread(this, thr_type, stack_sz);


  “지금 이 JavaThread를 실제 OS 스레드와 연결해서

  실행 가능한 상태로 만들어 줘.”



라고 OS 의존 레이어에 요청하는 함수다.



3. os::create_thread 내부 (Linux 기준)

이제 리눅스 구현을 보자.

// openjdk/jdk/src/hotspot/os/linux/os_linux.cpp

bool os::create_thread(Thread* thread, ThreadType thr_type, size_t req_stack_size) {
  // 1. OSThread 생성 및 연결
  OSThread* osthread = new (std::nothrow) OSThread();
  if (osthread == nullptr) return false;
  osthread-&gt;set_state(ALLOCATED);
  thread-&gt;set_osthread(osthread);

  // 2. pthread 속성 초기화
  pthread_attr_t attr;
  if (pthread_attr_init(&amp;attr) != 0) {
    thread-&gt;set_osthread(nullptr);
    delete osthread;
    return false;
  }
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);

  // 3. 스택 크기 계산 및 설정
  size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
  size_t guard_size = os::Linux::default_guard_size(thr_type);
  pthread_attr_setguardsize(&amp;attr, guard_size);
  pthread_attr_setstacksize(&amp;attr, stack_size);

  // 4. pthread_create 호출
  pthread_t tid;
  int ret = pthread_create(&amp;tid, &amp;attr,
                           (void* (*)(void*)) thread_native_entry,
                           thread);

  pthread_attr_destroy(&amp;attr);

  if (ret != 0) {
    thread-&gt;set_osthread(nullptr);
    delete osthread;
    return false;
  }

  // 5. 성공 시 OSThread에 pthread ID 기록
  osthread-&gt;set_pthread_id(tid);

  // 6. 자식 스레드 초기화 대기
  {
    Monitor* sync_with_child = osthread-&gt;startThread_lock();
    MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);
    while (osthread-&gt;get_state() == ALLOCATED) {
      sync_with_child-&gt;wait_without_safepoint_check();
    }
  }

  // 7. INITIALIZED 상태에서 true 반환
  return true;
}



이걸 단계별로 풀어보자.



4. 1단계 – OSThread 생성: OS 핸들을 관리할 껍데기

OSThread* osthread = new (std::nothrow) OSThread();
if (osthread == nullptr) return false;
osthread-&gt;set_state(ALLOCATED);
thread-&gt;set_osthread(osthread);




  여기서 OSThread는 OS 스레드 핸들을 감싸는 HotSpot 내부 객체다.
    
      pthread ID, native thread id, 시작 동기화용 모니터, 상태값 등을 가진다.
    
  
  이 시점에는 아직 OS 스레드를 만들지 않았다.
  상태를 ALLOCATED로 두고, JavaThread 쪽과 연결만 해둔다.


그림으로 보면:

JavaThread
  └─ OSThread (state = ALLOCATED)
       └─ (아직 OS thread 없음)





5. 2단계 – pthread_attr_t 초기화 + detach 모드 설정

pthread_attr_t attr;
if (pthread_attr_init(&amp;attr) != 0) {
  ...
}
pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);



PTHREAD_CREATE_DETACHED를 쓰면 detached 스레드가 만들어진다.


  joinable 스레드 (기본값)
    
      joinable 스레드를 만들면, 그 스레드가 끝나도 커널 안에 스레드 관련 정보가 남아 있다.
      그래서 언젠가는 pthread_join(tid, NULL);을 호출해 줘야 한다.
        
          이때 이 스레드가 다 끝났는지 확인하고 동시에 리소스를 정리해 준다.
        
      
      언제 쓰는가?
        
          이 스레드가 언제 끝나는지 반드시 알고 싶다.
          이 스레드 결과를 받아서 다음 작업을 하고 싶다.
          스레드가 다 끝난 뒤에 프로그램을 종료하고 싶다.
        
      
    
  
  detached 스레드
    
      언제 끝났는지 직접 확인하는 용도가 아니다.
      스레드가 끝나는 순간, OS가 이 스레드는 끝났다 하고 바로 관련 리소스를 정리한다.
      그래서 나중에 pthread_join(tid, ...)을 부를 수 없다.
      이미 정리된 정보라서 더 이상 joint 대상이 아니기 때문이다.
      언제 쓰는가?
        
          이 스레드가 언제 끝나는지 정확한 시점을 알 필요 없다.
          그냥 백그라운드에서 한 번 돌고 끝나면 된다.
        
      
    
  


한 줄 요약하면:


  joinable = “내가 직접 join해서 치우는 스레드”

  detached = “끝나면 OS가 알아서 치우는 스레드”





JVM이 내부 스레드를 detached로 자주 만드는 이유

HotSpot JVM이 내부에서 OS 스레드를 만들 때는, 보통 이렇게 생각하면 된다.


  자바 코드에서 pthread_join()을 직접 호출할 일은 없다.
  OS 스레드의 생명주기/리소스 정리는 JVM이 전체적으로 관리한다.
  자바 개발자는 Thread.join() 같은 자바 API만 쓰면 된다.


그래서 JVM 입장에서는:


  
    OS 레벨에서는 detached로 만들어 두면

    → 스레드가 끝날 때 커널이 자동으로 리소스를 정리해 준다.
  
  
    자바 레벨에서는

    → “저 Thread가 끝났는지”는 JavaThread/Thread 상태로 관리하고

    → join()이 오면 wait/notify로 자바 쪽에서만 기다리도록 구현한다.
  


즉,


  OS 레벨 리소스 청소 = detached + 커널

  자바 레벨 동기화/대기 = JVM + Thread.join()



으로 역할을 분리해 둔 구조라고 보면 된다.



Java join() vs pthread_join() 차이

pthread_join() (C/POSIX)


  대상 OS 스레드가 끝날 때까지 현재 스레드를 블록시키고,
  동시에 그 스레드의 커널 리소스를 회수한다.
  “OS 스레드에 직접 붙어서 기다리는 함수”


Thread.join() (Java)


  OS 함수 래핑이 아니라, JVM이 구현한 고수준 동기화 메서드다.
  내부적으로는
    
      JavaThread / 자바 Thread의 상태를 보고
      아직 안 끝났으면 wait/notify 패턴으로 블록시킨다.
    
  
  OS 레벨 pthread_join()을 직접 호출해서 자바 스레드마다 join하는 구조가 아니다.


그래서 Java 관점에서는:


  “OS 스레드를 join한다기보다는,

  JVM이 관리하는 ‘자바 스레드 상태’가 끝날 때까지 기다린다”





6. 3단계 – 스택 크기 &amp; 가드 페이지 설정

size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
size_t guard_size = os::Linux::default_guard_size(thr_type);
pthread_attr_setguardsize(&amp;attr, guard_size);
pthread_attr_setstacksize(&amp;attr, stack_size);




  tack_size → 이 스레드가 사용할 스택 크기를 최종 결정
  guard_size → 스택 끝에 둘 “보호용 메모리 영역” 크기 결정
  둘 다 pthread_attr_t에 반영해서 pthread_create할 때 같이 넘김




A. 스택 크기 결정 – “얼마만큼 스택을 쓸지 최종 확정”

스레드마다 자기만 쓰는 스택 메모리가 있다.

여기서 하는 일:


  
    자바에서 new Thread(null, runnable, "t", stackSize) 같은 식으로

    stackSize를 직접 지정했을 수도 있고, 안 했을 수도 있다.
  
  JVM은 req_stack_size(요청값)와
    
      JVM 기본값
      
        OS가 허용하는 최소/최대 스택 크기

        를 모두 고려해서 최종 stack_size를 만든다.
      
    
  
  
    pthread_attr_setstacksize(&amp;attr, stack_size)로

    “이 스레드는 이만큼 스택을 쓰겠다”고 명시해 준다.
  


이걸 안 하고 OS 기본값만 쓰면,


  어떤 환경에서는 스택이 너무 작아서 금방 터질 수도 있고,
  반대로 너무 크게 잡혀서 불필요하게 메모리를 많이 점유할 수도 있다.


그래서 JVM이 “JVM이 원하는 기준”에 맞춰 스택 크기를 컨트롤하는 거라고 보면 된다.

B. 가드 페이지(guard page) – “스택 오버플로를 잡아내기 위한 안전 장치”

guard_size는 가드 페이지 크기다.


  스택의 끝 부분에 일부 페이지를 “접근 불가 메모리”로 막아 두는 것이다.
  코드가 스택을 너무 많이 써서 스택 끝을 넘어서면:
    
      그 막아 둔 영역을 건드리게 되고
      
        즉시 SIGSEGV(세그멘테이션 폴트)가 나면서 프로세스가 죽거나,

        JVM이 “스택 오버플로 발생”을 감지할 수 있게 된다.
      
    
  


정리하면:


  
    가드 페이지가 있으면

    → “스택 끝을 넘는 순간 바로 터져서, 문제 지점을 빨리 알 수 있다.”
  
  
    가드 페이지가 없으면

    → 스택을 넘어서 다른 메모리까지 침범해 버려서

    조용히 메모리를 망가뜨리고, 나중에 엉뚱한 곳에서 터져 디버깅이 어려워진다.
  




7. 4단계 – 핵심: pthread_create 호출

pthread_t tid;
int ret = pthread_create(&amp;tid, &amp;attr,
                         (void* (*)(void*)) thread_native_entry,
                         thread);


여기가 “새 OS 스레드 하나 주세요”라고 OS에 요청하는 부분이다.


  
    첫 번째 인자 &amp;tid

    → 새로 만들어지는 스레드의 pthread ID를 돌려받을 변수 주소

    → pthread_create가 성공하면 이 변수에 새 스레드 ID를 넣어 준다.
  
  
    두 번째 인자 &amp;attr

    → 방금 설정한 스택/가드/detach 속성.

    → 이걸 넘기면 OS가 이 옵션대로 스레드를 만든다.
  
  
    세 번째 인자 thread_native_entry

    → 새 스레드가 시작하면 제일 먼저 실행할 함수 주소

    
      OS 입장에서는 새 스레드를 만들고, 그 스레드에서 이 함수를 호출하게 한다.
      이 함수 안에서  JVM이 초기화 작업을 하고, 자바 쪽 Thread.run()까지 연결해 준다.
    
  
  
    네 번째 인자 thread

    → start routine에 전달할 인자 (여기서는 Thread*, 보통 JavaThread*).
  


thread_native_entry는 HotSpot 안에 정의된 함수로,

새로 생성된 OS 스레드가 바로 들어가는 C 함수다. (이건 Part 4에서 깊게 본다.)

7-1. 실패 처리

pthread_attr_destroy(&amp;attr);

if (ret != 0) {
  thread-&gt;set_osthread(nullptr);
  delete osthread;
  return false;
}




  스레드 생성이 실패하면:
    
      osthread를 정리하고
      
        false 를 반환해서 상위(JavaThread → JVM_StartThread)에서

        OutOfMemoryError("Failed to create native thread") 를 던질 수 있도록 한다.

          // JVM_StartThread() 메서드 내 코드
     JavaThread* native_thread = nullptr;
     ...
     ...
     if (native_thread-&gt;osthread() == nullptr) {
      THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), "Failed to create native thread");
     }
        
      
    
  




8. 5단계 – 성공한 경우: OSThread에 pthread ID 기록 + 자식 초기화 대기

스레드 생성이 성공했다면:

osthread-&gt;set_pthread_id(tid);



  OSThread에 pthread ID를 기록한다.
  디버깅/로그/시그널 라우팅 등에 사용된다.


그리고 바로 자식(새 스레드)의 초기화를 기다리는 단계로 들어간다.

{
  Monitor* sync_with_child = osthread-&gt;startThread_lock();
  MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);
  while (osthread-&gt;get_state() == ALLOCATED) {
    sync_with_child-&gt;wait_without_safepoint_check();
  }
}


여기서 중요한 포인트:


  부모(현재 os::create_thread를 실행 중인 스레드)는
    
      startThread_lock 라는 모니터(뮤텍스 + 조건변수)를 잡고,
      OSThread 상태가 ALLOCATED 에서 다른 상태로 바뀔 때까지 기다린다.
    
  
  자식(새로 만들어진 OS 스레드)은
    
      thread_native_entry 안에서 초기화 작업을 수행한 뒤,
      OSThread 상태를 INITIALIZED 등으로 바꾸고,
      같은 startThread_lock 모니터에서 notify()를 호출해 부모를 깨운다.
    
  


즉, 이 단계는:


  “스레드는 이미 만들어졌는데,

  자식이 최소한의 VM 초기화(OSThread 상태 세팅 등)를 끝낼 때까지

  부모가 잠깐 기다리는 구간”



이라고 보면 된다.

자식이 INITIALIZED 상태까지 올라간 뒤에야

상위에서 Thread::start → os::start_thread → pd_start_thread 를 호출하여

실제 RUNNABLE 상태로 전환시킬 수 있다.

(이 start barrier와 핸드셰이크 세부 내용은 Part 4에서 연결된다.)



9. glibc란 무엇이고, 왜 pthread_create를 쓰는가?

지금까지는 HotSpot 코드 레벨이었다.

하지만 pthread_create 자체도 “사용자 공간 라이브러리 함수”다.

한 단계 더 내려가보자.

9-1. glibc = GNU C Library


  리눅스에서 가장 널리 쓰이는 표준 C 라이브러리 구현.
  우리가 C에서 쓰는 대부분의 함수:
    
      printf, malloc, free
      open, read, write
      
        pthread_create, pthread_join

        전부 glibc 안에 들어 있다.
      
    
  


역할:


  각종 시스템 콜(syscall)을 감싸서 이식성 있고 쓰기 편한 API를 제공한다.
  직접 syscall 어셈블리로 호출하는 대신,
    
      glibc 함수 하나로 OS 의존성을 숨기고,
      POSIX/ISO C 표준 인터페이스를 맞춰준다.
    
  


9-2. JVM이 clone()을 직접 호출하지 않고 pthread_create를 쓰는 이유

리눅스 커널에서 스레드/프로세스를 만드는 시스템콜은 clone() 이다.

그런데 HotSpot은 대부분 이걸 직접 쓰지 않고, pthread_create 를 사용한다.

이유:


  POSIX 호환
    
      pthread API는 POSIX 표준에 맞게 설계되어 있고,
      다른 유닉스 계열 OS에서도 거의 동일하게 동작한다.
    
  
  이식성
    
      JVM은 여러 유닉스 계열(리눅스, BSD, macOS 등)을 지원해야 한다.
      
        각각의 커널 syscall을 직접 다루는 것보다는

        pthread_* 계열 API 위에 얹는 게 훨씬 유지보수에 좋다.
      
    
  
  추가 편의 기능
    
      pthread_create는 단순히 clone()만 감싸는 게 아니라,
        
          스레드 속성,
          signal mask,
          
            TLS 초기화 등

            여러 준비 작업을 함께 처리해 준다.
          
        
      
    
  


정리하면:


  HotSpot(유저 공간 프로그램)이 OS 스레드를 만들 때

  glibc가 제공하는 pthread_create를 사용하고,

  glibc는 내부에서 clone() 시스템콜로 커널에 요청한다.





10. 커널 레벨 – clone() 시스템콜과 task_struct

이제 마지막 레벨, 리눅스 커널.

10-1. clone() 시스템콜


  리눅스에서 프로세스/스레드 생성에 쓰이는 시스템콜이다.
  fork()와 달리, 어떤 자원을 부모와 공유할지 플래그로 지정할 수 있다.
    
      CLONE_VM → 주소 공간 공유 (스레드)
      CLONE_FILES → 열린 파일 디스크립터 공유
      CLONE_SIGHAND → 시그널 핸들 공유
    
  
  
    일반적인 POSIX 스레드 구현에서는 이 플래그들을 적절히 조합해

    “같은 프로세스 안에서 주소 공간을 공유하는 스레드”를 만든다.
  


10-2. 커널 내부에서 하는 일 (개념적으로)


  새 task_struct 할당
    
      리눅스 커널에서 스레드/프로세스를 나타내는 구조체.
    
  
  부모의 주소 공간, 파일, 시그널 핸들 등을 공유/복사할지 플래그에 따라 처리.
  스택/레지스터 초기값 세팅
  스케줄러 큐에 새 task 등록


그리고:


  시스템콜이 성공하면 부모 쪽에는 새 스레드 ID를 반환하고,
  자식 쪽에서는 지정된 start routine의 첫 줄부터 실행을 시작한다.




11. 세 레벨 요약: HotSpot ↔ glibc ↔ 커널

지금까지의 흐름을 한 번에 정리하면:

[HotSpot 레벨]  (OpenJDK / libjvm.so)
---------------------------------------
JVM_StartThread
  → new JavaThread(thread_entry, stackSize)
      → os::create_thread(this, thr_type, stackSize)
          → pthread_attr_init / setstacksize / setguardsize
          → pthread_create(&amp;tid, &amp;attr, thread_native_entry, thread)
              ↓

[glibc 레벨]    (libpthread.so / glibc)
---------------------------------------
pthread_create(...)
  → clone(...) 시스템콜 래퍼
      ↓

[커널 레벨]     (Linux kernel)
---------------------------------------
clone(...)
  → task_struct 생성
  → 주소 공간/파일/시그널 공유 설정
  → 스케줄러에 새 스레드 등록
  → 새 스레드에서 start routine(thread_native_entry) 실행 시작



이렇게 보면, 우리가 자바에서 친 t.start() 한 줄이:


  JVM C++ 코드 (JavaThread, OSThread)
  glibc (pthread_create)
  리눅스 커널 (clone, task_struct, 스케줄러)


를 층층이 타고 내려가면서 OS 스레드를 만드는 동작이라는 게 보인다.

Part 3는 이 중에서 “HotSpot → glibc → 커널로 내려가는 과정”까지.

Part 4에서는 새로 만들어진 스레드가

thread_native_entry → JavaThread::run → thread_entry → Thread.run() 으로

다시 자바 세계로 올라오는 길을 따라갈 예정이다.



12. Part 3 정리

핵심만 다시 뽑으면:


  JavaThread 생성자에서 os::create_thread(this, thr_type, stackSize) 호출
  os::create_thread (Linux 기준):
    
      OSThread 객체 생성, 상태 ALLOCATED
      pthread_attr_t 초기화, detach 모드 설정
      스택 크기, 가드 페이지 설정
      pthread_create(&amp;tid, &amp;attr, thread_native_entry, thread) 호출
      성공 시 OSThread에 pthread ID 저장
      startThread_lock 모니터로 자식 스레드 초기화 완료까지 대기
    
  
  pthread_create는 glibc 함수로, 내부에서 clone() 시스템콜을 호출
  
    리눅스 커널은 clone()을 통해 새 task_struct를 만들고,

    스케줄러에 등록한 뒤, 새 스레드에서 thread_native_entry를 실행 시작
  
  
    이렇게 해서 자바의 Thread 객체는

    JVM 내부 JavaThread ↔ OSThread ↔ OS 커널 스레드와 1:1로 연결된다 (플랫폼 스레드 기준).
  


                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2025-10-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/java-thread-start-part2-start0-jvm-startthread-javathread.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/thread-start.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/java-thread-start-part2-start0-jvm-startthread-javathread.html"><h1 class="title_post">[Java Multithreading] Part 2 – Thread.start() 뒤에서 일어나는 일: registerNatives ~ JVM_StartThread ~ JavaThread</h1></a>
                        <a href="/Java/java-thread-start-part2-start0-jvm-startthread-javathread.html" class="txt_post">
                            [Java Multithreading] Part 2 – Thread.start() 뒤에서 일어나는 일: registerNatives ~ JVM_StartThread ~ JavaThread

시리즈 전체 보기


  Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교
  Part 2 – Thread.start() 뒤에서 일어나는 일: start0() ~ JVM_StartThread ~ JavaThread
  Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()
  Part 4 – 새로운 스레드가 자바 run()에 도달하기까지:  thread_native_entry → JavaThread::run → thread_entry → Thread.run()
  마지막 글 – 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태


0. 이 글에서 다룰 범위

Part 1에서 정리한 핵심은 딱 이거였다.


  run() 직접 호출 → 새 스레드 안 만들고 현재 스레드에서 그냥 메서드 호출
  start() 호출 → JVM이 OS 스레드를 새로 만들고, 그 스레드에서 run() 실행


그런데 “JVM이 OS 스레드를 새로 만든다” 라고만 하면 너무 추상적이다.

Part 2에서는 자바 → 네이티브로 넘어가는 첫 구간을 따라간다:


  Thread 클래스 로딩

  → registerNatives()

  → native void start0()

  → JVM_StartThread

  → JavaThread 생성까지



실제 OS 스레드(pthread_create, clone() 등)는 Part 3,

새 스레드가 run()까지 도달하는 길(thread_entry, JavaThread::run)은 Part 4에서 본다.



1. Thread 클래스 로딩 시점: registerNatives() 호출

먼저, java.lang.Thread의 일부이다.

public class Thread implements Runnable {
    /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
    private static native void registerNatives();
    static {
        registerNatives();
    }

    ...
}



여기서 중요한 포인트는 세 가지다.

1-1. 정적 초기화 블록과 &lt;clinit&gt;


  static { ... } 는 정적 초기화 블록이다.
  자바 클래스는 JVM에서
    
      로드(load)
      링크(link)
      
        초기화(initialize)

        단계를 거친다.
      
    
  
  이 중 초기화 단계에서
    
      static 필드 초기값 설정
      
        static { ... } 블록 실행

        을 한다.
      
    
  
  이 초기화 동작은 클래스당 딱 한 번만 일어난다.


즉, Thread 클래스가 처음 사용되는 시점에

registerNatives() 도 단 한 번 호출된다.

1-2. 왜 Thread에서 registerNatives()를 쓰나?

Thread 클래스 안에는 이런 메서드들이 있다.

private native void start0();
private static native void sleep(long millis) throws InterruptedException;
private static native void yield();
...




  이런 메서드는 자바 코드 구현이 없고, OS 의존적인 내부 동작(스레드 생성, sleep, yield 등)을 수행해야 한다.
  따라서 실제 구현은 C/C++ 로 작성되어 있고, JVM이 JNI(Java Native Interface) 를 통해 호출한다.


문제는:


  자바 입장에서는 그냥 start0() 이라는 이름만 알고,
  JVM 내부 C/C++ 함수 이름은 JVM_StartThread 같은 형태로 따로 있다.


그래서 JVM이 둘을 연결해 줘야 한다.

그 작업을 하는 게 바로 registerNatives() 다.

1-3. “에서 제일 먼저 해야 하는 일”

주석을 다시 보자.

/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */




  &lt;clinit&gt;은 컴파일러가 만드는 “클래스 초기화 메서드” 이름이다.
  이 안에서 제일 먼저 registerNatives()를 호출하라는 의미다.


왜냐면:


  registerNatives()가 네이티브 메서드 → C 함수 포인터 매핑을 등록하기 전에
  자바 코드에서 start0(), sleep() 같은 네이티브를 호출해 버리면
  아직 연결이 안 돼 있어서 UnsatisfiedLinkError 가 날 수 있다.


그래서:


  Thread 클래스가 로딩/초기화될 때

  제일 먼저 네이티브 매핑을 등록해 둔다.





2. C 쪽 구현: Java_java_lang_Thread_registerNatives

이제 OpenJDK 네이티브 코드를 보자.

https://github.com/openjdk/jdk

// openjdk/src/java.base/share/native/libjava/Thread.c

static JNINativeMethod methods[] = {
    {"start0", "()V", (void *)&amp;JVM_StartThread},
    // ... sleep, yield 등 다른 메서드들
};

JNIEXPORT void JNICALL
Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls) {
    (*env)-&gt;RegisterNatives(env, cls, methods,
            sizeof(methods)/sizeof(methods[0]));
}



여기서 나오는 개념들을 하나씩 정리해 보자.

2-1. JNINativeMethod 구조체

typedef struct {
    const char* name;       // 자바 메서드 이름
    const char* signature;  // 시그니처 문자열 (예: "()V", "(J)V")
    void*       fnPtr;      // 네이티브 함수 포인터
} JNINativeMethod;




  name : 자바 쪽 메서드 이름 ("start0")
  signature : 메서드 시그니처
    
      ()V → 인자 없음, 반환 void
      (J)V → long 하나 받고, 반환 void 등
    
  
  fnPtr : 실제 호출할 C 함수 주소 (&amp;JVM_StartThread)


즉, 이 한 줄로

{"start0", "()V", (void *)&amp;JVM_StartThread}




  “자바의 private native void start0() 는

  C 함수 JVM_StartThread 로 연결된다”



라는 매핑 정보를 JVM에 준 셈이다.

2-2. JNI 네이밍 규칙: Java_패키지_클래스_메서드

Java_java_lang_Thread_registerNatives 라는 이름은

JNI 네이밍 규칙에 따라 만들어진 함수다.


  Java_ + java_lang_Thread + _registerNatives
  자바의 java.lang.Thread.registerNatives() 메서드와 연결된다.


JVM은 registerNatives()를 호출할 때 이 네이티브 함수를 찾아 실행한다.

2-3. RegisterNatives 호출

(*env)-&gt;RegisterNatives(env, cls, methods,
    sizeof(methods)/sizeof(methods[0]));




  env : JNI 환경 포인터. JNI 함수들을 호출하는 “핸들”이다.
  cls : java.lang.Thread.class에 해당하는 JNI 타입(jclass).
  methods 배열을 넘기면,
    
      
        JVM은 Thread 클래스 내부의 네이티브 메서드 테이블에

        "start0" → JVM_StartThread 같은 매핑을 등록한다.
      
    
  


이제 자바 코드에서 start0()을 호출하면, JVM은 이 테이블을 보고

어떤 C 함수를 호출해야 할지 알게 된다.



3. start() → start0() → 매핑된 네이티브 함수 호출

자바 쪽 start()는 Part 1에서 봤듯이 이렇게 생겼다.

public void start() {
    synchronized (this) {
        if (holder.threadStatus != 0)
            throw new IllegalThreadStateException();
        start0();
    }
}



핵심:


  자바 코드에서 할 수 있는 일
    
      상태 체크 (threadStatus == 0 인지)
      동기화 (synchronized (this))
    
  
  실제 스레드 생성은 못 한다.
    
      OS API 호출은 자바 레벨에서 직접 못 하기 때문.
    
  


그래서 마지막에:

private native void start0();


를 호출한다. 이 순간:


  JVM은 Thread 클래스의 네이티브 테이블에서 "start0"을 찾는다.
  JVM_StartThread 함수 포인터가 매핑되어 있음.
  자바 스택에서 네이티브(호출자: JVM) 스택으로 전환하면서 C 함수 JVM_StartThread로 점프한다.




4. JVM_StartThread – JVM 내부에서 진짜 “스레드”를 만드는 시작점

이제 OpenJDK의 JVM_StartThread 쪽 코드 흐름을 보자.

(실제 코드는 훨씬 길고 복잡하니, 핵심만 간추린 형태로 본다.)

JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
  JavaThread* native_thread = nullptr;
  bool throw_illegal_thread_state = false;

  {
    MutexLocker ml(Threads_lock);

    // 1. 이미 시작된 Thread인지 확인
    if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != nullptr) {
      throw_illegal_thread_state = true;
    } else {
      // 2. 자바 Thread의 stackSize 가져오기
      jlong size = java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
      size_t sz = size &gt; 0 ? (size_t)size : 0;

      // 3. C++ 레벨 JavaThread 객체 생성 (실행 단위의 뼈대)
      native_thread = new JavaThread(&amp;thread_entry, sz);

      // 4. 자바 Thread 객체와 JavaThread 연결
      if (native_thread-&gt;osthread() != nullptr) {
        native_thread-&gt;prepare(jthread);
      }
    }
  }

  // 5. 예외 처리: 이미 시작된 Thread인 경우
  if (throw_illegal_thread_state) {
    THROW(vmSymbols::java_lang_IllegalThreadStateException());
  }

  // 6. OS 스레드 생성 실패한 경우
  if (native_thread-&gt;osthread() == nullptr) {
    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), "Failed to create native thread");
  }

  // 7. 실제 실행 시작 (OS 스케줄러에 등록)
  Thread::start(native_thread);
JVM_END



4-1. 매개변수: JNIEnv* env, jobject jthread


  jthread : 자바 힙에 있는 java.lang.Thread 인스턴스를 가리키는 JNI 핸들이다.
    
      우리가 자바에서 t.start()를 호출했다면, 이 t가 여기로 들어온다.
    
  
  JNIHandles::resolve_non_null(jthread) 는 JNI 핸들을 실제 oop(자바 객체 포인터)로 변환해 준다.


4-2. 이미 시작된 Thread인지 검사

if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != nullptr) {
    throw_illegal_thread_state = true;
}



  자바의 Thread 객체와 매핑된 JavaThread 가 이미 있는지 확인한다.
  이미 있다면 = 이미 한 번 start() 된 스레드.
  이 경우, 자바 코드와 동일하게 IllegalThreadStateException을 던진다.


여기서 바로 예외를 던지지 않고,

throw_illegal_thread_state 플래그만 세우고 잠시 밖으로 나가는 이유는:


  안쪽 블록 { MutexLocker ml(Threads_lock); ... } 에서 Threads_lock 이라는 전역 락을 잡고 있기 때문.
  
    락을 쥔 상태로 예외를 던지면, 락 해제 타이밍이 꼬일 수 있으니

    먼저 블록을 빠져나가 락을 해제한 후에 예외를 던진다.
  


4-3. JavaThread 생성

native_thread = new JavaThread(&amp;thread_entry, sz);


여기서 정말 중요한 타입이 하나 나온다.


  JavaThread
    
      HotSpot JVM 내부에서 “자바 스레드”를 나타내는 C++ 클래스.
      자바 Thread 객체와 OS 스레드 사이를 이어주는 JVM 레벨 추상화다.
      생성자 인자:
        
          entry_point : 새 스레드가 시작하면 실제로 호출할 C++ 함수 포인터
            
              여기서는 thread_entry 가 들어간다.
            
          
          sz : 스택 크기 힌트
        
      
    
  


이 시점에서 하는 일은 대략:


  JVM 내부에 JavaThread C++ 객체를 하나 만든다.
  
    내부에서 os::create_thread(this, thr_type, stack_sz) 를 호출해

    OS 스레드 생성(pthread 등)을 시도한다. (이건 Part 3에서 자세히 보기)
  
  OS 스레드 생성에 성공하면, JavaThread 안에 OSThread* 필드를 채운다.


// openjdk/jdk/src/hotspot/share/runtime/javaThread.cpp

JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MemTag mem_tag) 
  : JavaThread(mem_tag) {
  set_entry_point(entry_point);

  // 어떤 타입의 스레드인지 결정
  os::ThreadType thr_type = os::java_thread;
  thr_type = entry_point == &amp;CompilerThread::thread_entry 
             ? os::compiler_thread 
             : os::java_thread;

  // 실제 OS 스레드 생성
  os::create_thread(this, thr_type, stack_sz);

  // 이 시점에서 _osthread는 null일 수 있음 (리소스 부족 같은 경우)
  // 따라서 바로 예외를 던지지 않고, 상위 호출자(JVM_StartThread)가 나중에 처리
  //
  // 그리고 여기서 바로 실행 시작되지 않음
  // 반드시 creator가 명시적으로 os::start_thread()를 불러줘야 스레드가 달리기 시작
  // (Threads::add() 호출도 마찬가지로 JVM_StartThread 쪽에서 처리)
}



즉, new JavaThread(...) 는


  “JVM 내부 스레드 객체 생성 + OS 스레드 생성 요청”



을 함께 수행하는 동작이다.

4-4. 자바 Thread 객체와 JavaThread 연결: prepare(jthread)

if (native_thread-&gt;osthread() != nullptr) {
    native_thread-&gt;prepare(jthread);
}



  native_thread-&gt;osthread() 가 nullptr 이 아니라는 것은
    
      OS 스레드가 정상적으로 생성됐다는 뜻이다.
    
  
  prepare(jthread) 는
    
      C++ JavaThread 객체와
      
        자바 Thread 객체(jthread)

        를 양방향으로 연결해 주는 작업이다.
      
    
  


대략적인 개념은 이렇다:


  JavaThread 안에 “내가 담당하는 자바 Thread 객체(oop)”를 저장.
  자바 Thread 객체의 필드에도 “나와 연결된 JavaThread 주소”를 저장.
  나중에 어느 쪽에서든 서로를 찾을 수 있도록 매핑을 만들어 둔다.


이 작업 덕분에:


  
    자바 코드에서 Thread.currentThread() 를 호출하면

    → 현재 OS 스레드에 매핑된 JavaThread

    → 거기에서 연결된 자바 Thread 객체를 찾아 돌려줄 수 있다.
  




5. JavaThread vs OSThread vs 자바 Thread 객체

여기까지 나오면 스레드 관련해서 이름이 헷갈리기 딱 좋다. 구조를 한 번 정리하고 가자.

5-1. 3단 구조

개념적으로는 이렇게 생겼다:

[OS 커널 스레드]
    ↑
  OSThread     (OS 핸들, pthread_t, Windows HANDLE 등)
    ↑
  JavaThread   (JVM 내부 C++ 스레드 객체)
    ↑
java.lang.Thread (자바 힙 객체)




  OS 커널 스레드
    
      실제 CPU 위에서 돌아가는 실행 단위.
      리눅스라면 task_struct, clone() 으로 만들어지는 그 대상.
    
  
  OSThread (HotSpot C++ 클래스)
    
      OS 스레드 핸들을 감싸는 플랫폼 의존 레이어.
      내부에 pthread_t, 스레드 ID, 네이티브 핸들 등을 들고 있는 구조체/클래스.
    
  
  JavaThread (HotSpot C++ 클래스)
    
      JVM이 관리하는 플랫폼 독립 레벨 스레드 객체.
      GC, safepoint, JIT, 디버거/JVMTI 등 JVM 내부 기능과 깊이 연결되어 있다.
      필드 중 하나로 OSThread* _osthread 를 가지고 있어 OS 스레드와 연결된다.
      또 하나의 핸들로, 자바의 java.lang.Thread 객체(oop)를 들고 있다.
    
  
  자바의 Thread 객체
    
      우리가 자바 코드에서 new Thread(...) 로 만드는 인스턴스.
      이름, priority, daemon 여부, run() 로직, stackSize 설정 등을 가진다.
      내부적으로 JavaThread / OSThread 와 연결되어 실제 실행 단위를 제어한다.
    
  


5-2. 왜 JavaThread와 OSThread를 나누었을까?

핵심 이유는 두 가지다.


  플랫폼 독립성
    
      OS 스레드 표현은 OS마다 다르다.
        
          리눅스: pthread_t
          윈도우: HANDLE, DWORD id 등
        
      
      만약 JVM의 스레드 로직이 이런 OS 타입에 직접 의존하면,
        
          리눅스/윈도우/맥마다 코드가 죄다 달라져야 한다.
        
      
      그래서
        
          JavaThread : GC, JIT, safepoint 등 JVM 공통 로직
          
            OSThread : OS 핸들, native id 등 플랫폼 의존 로직

            로 분리해서 관리한다.
          
        
      
    
  
  JVM 내부 기능과의 결합
    
      GC, safepoint, 디버거, JFR 같은 기능은 모두 JVM 레벨에서 스레드를 관리해야 한다.
      
        이때 필요한 상태(스레드 state, 스택 정보, TLS, Java 프레임 정보 등)는

        OS 스레드 수준에는 없다.
      
      
        그래서 JVM이 필요한 모든 메타데이터를 JavaThread에 담고,

        OS 스레드는 그냥 “실행 수단”으로만 본다.
      
    
  




6. JVM_StartThread의 예외 처리

이제 앞부분에서 스킵했던 예외 처리 코드를 다시 보자.

if (throw_illegal_thread_state) {
  THROW(vmSymbols::java_lang_IllegalThreadStateException());
}

if (native_thread-&gt;osthread() == nullptr) {
  THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), "Failed to create native thread");
}




  이미 시작된 Thread인 경우
    
      
        자바 레벨에서 start()를 두 번 호출하면 예외가 나는 이유를

        JVM도 동일하게 맞춰준다.
      
      
        여기서는 네이티브 코드에서 예외 객체를 생성하고,

        자바 호출 스택으로 되돌려 보내는 역할을 한다.
      
    
  
  OS 스레드 생성 실패
    
      리소스 부족, OS 스레드 제한 초과 등으로 os::create_thread 가 실패하면
      osthread() 가 nullptr 로 남는다.
      이 경우 OutOfMemoryError("Failed to create native thread")를 던진다.
      스레드를 너무 많이 만들어서 JVM이 OutOfMemoryError: unable to create new native thread 를 던진다는 것은 여기서 발생하게 되는 것이다.
    
  




7. C++ 쪽 Thread::start(native_thread) – OS에 실제 실행을 요청하는 단계

자바 쪽 Thread.start() 말고,

C++ 쪽에도 Thread::start(Thread*) 라는 함수가 있다. (이름이 같아서 헷갈리기 쉽다.)

// openjdk/src/hotspot/share/runtime/thread.cpp

void Thread::start(Thread* thread) {
  if (thread-&gt;is_Java_thread()) {
    java_lang_Thread::set_thread_status(
        JavaThread::cast(thread)-&gt;threadObj(),
        JavaThreadStatus::RUNNABLE);
  }
  os::start_thread(thread);
}



여기서 하는 일:


  자바 Thread 상태를 RUNNABLE로 설정
    
      자바 쪽에서 getState() 등을 호출할 때 보는 상태를 맞춰준다.
      
        아직 실제로 CPU에서 돌고 있는 건 아니지만,

        “실행 가능한 상태”로 만든다.
      
    
  
  os::start_thread(thread) 호출
    
      OS 의존 레이어로 내려간다.
      내부에서 pd_start_thread(thread) 를 호출한다.
      
        이 부분은 “부모/자식 스레드 핸드셰이크”, “start barrier”를 다루는 구간이고

        자세한 내용은 Part 3~4에서 본다.
      
    
  


7-1. os::start_thread와 OS별 구현 결합

소스 구조는 대략 이런 식이다.

// 공통 코드: openjdk/jdk/src/hotspot/share/runtime/os.cpp
void os::start_thread(Thread* thread) {
  OSThread* osthread = thread-&gt;osthread();
  osthread-&gt;set_state(RUNNABLE);
  pd_start_thread(thread);   // platform dependent 구현 호출
}



// 리눅스 구현: openjdk/jdk/src/hotspot/os/linux/os_linux.cpp
void os::pd_start_thread(Thread* thread) {
  ...
  sync_with_child-&gt;notify(); // 자식 스레드 깨우는 신호
}




  os::start_thread 는 플랫폼 독립 레이어
    
      공통 상태 전환, 디버깅 훅, 공통 invariant 체크 등을 담당.
    
  
  pd_start_thread 는 플랫폼 의존 레이어
    
      리눅스/윈도우/맥마다 구현이 다르다.
      빌드할 때, 현재 타겟 OS에 맞는 파일만 컴파일/링크해서 붙인다.
    
  


즉:


  소스 레벨에서는 os::start_thread 를 호출하지만,

  빌드 타임에 OS별 구현(os_linux.cpp 등)과 심볼이 묶이기 때문에

  실행 시에는 적절한 플랫폼 구현으로 바로 점프한다.





8. Part 2 전체 흐름 요약

지금까지를 “Thread.start() 뒤에서 벌어지는 일” 관점에서 정리하면:


  JVM 부팅 초반
    
      java.lang.Thread 클래스 로딩
      &lt;clinit&gt; 안에서 registerNatives() 호출
      JNI의 RegisterNatives를 통해
        
          "start0" → JVM_StartThread
          "sleep" → JVM_Sleep
          
            …

            매핑 테이블 등록
          
        
      
    
  
  자바 코드에서 t.start() 호출
    
      자바 Thread.start() 실행
      synchronized(this) 로 중복 start 방지
      상태 체크 후 start0() 호출
    
  
  네이티브 start0() → JVM_StartThread 진입
    
      JNI 테이블을 통해 JVM_StartThread C++ 함수로 점프
    
  
  JVM_StartThread 내부
    
      jthread(자바 Thread 객체)로부터 정보 추출
      이미 시작된 스레드인지 확인 → IllegalThreadStateException 대비
      new JavaThread(thread_entry, stackSize) 로 JVM 내부 스레드 객체 생성
        
          이 과정에서 OS 스레드 생성 시도 (os::create_thread) (Part 3)
        
      
      JavaThread.prepare(jthread) 로 자바 Thread 객체와 네이티브 스레드를 연결
      실패 시 OutOfMemoryError 등 예외 처리
      성공 시 Thread::start(native_thread) 호출
    
  
  C++ Thread::start
    
      자바 Thread 상태를 RUNNABLE 로 세팅
      os::start_thread(native_thread) 호출 → OS 의존 레이어로 내려감
    
  
  다음 파트
    
      
        Part 3: os::create_thread → pthread_create → glibc → clone() 까지

        진짜 OS 스레드가 어떻게 만들어지는지
      
      
        Part 4: 새 스레드가 시작 루틴(thread_native_entry, JavaThread::run, thread_entry)을 지나

        최종적으로 자바 Thread.run() 에 도달하는 흐름
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2025-10-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/java-thread-start-part1-start-vs-run-code-and-flow.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/thread-start.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/java-thread-start-part1-start-vs-run-code-and-flow.html"><h1 class="title_post">[Java Multithreading] Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교</h1></a>
                        <a href="/Java/java-thread-start-part1-start-vs-run-code-and-flow.html" class="txt_post">
                            시리즈 전체 보기


  Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교
  Part 2 – Thread.start() 뒤에서 일어나는 일: start0() ~ JVM_StartThread ~ JavaThread
  Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()
  Part 4 – 새로운 스레드가 자바 run()에 도달하기까지:  thread_native_entry → JavaThread::run → thread_entry → Thread.run()
  마지막 글 – 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태


[Java Multithreading] Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교

0. 왜 start() vs run()이 헷갈릴까?

스레드 예제를 따라 쓰다 보면 이런 코드를 많이 본다:

Thread t = new Thread(() -&gt; {
    System.out.println("작업: " + Thread.currentThread().getName());
});

// (1)
t.run();

// (2)
t.start();



코드만 보면 둘 다 “스레드의 일을 시작한다”는 느낌이라 비슷해 보인다.

하지만 실제로 돌려 보면:


  run()을 직접 호출하면 main 스레드에서 코드가 실행되고,
  start()를 호출하면 새로운 스레드가 만들어져 거기서 run()이 실행된다.


이 차이가 정확히 어디서 갈리는지를 Part 1에서 “자바 코드 기준으로만” 정리해본다.

(JNI, JVM_StartThread, pthread_create 같은 내부 구현은 Part 2~4에서 깊게 파본다.)



1. 실험 코드로 보는 run() vs start()

먼저 가장 기본적인 비교 코드를 보자.

public class ThreadStartVsRun {

    public static void main(String[] args) {
        System.out.println("[main] 시작 스레드 = " + Thread.currentThread().getName());

        Thread t1 = new Thread(() -&gt; {
            System.out.println("[t1.run 호출] 현재 스레드 = " + Thread.currentThread().getName());
        });

        Thread t2 = new Thread(() -&gt; {
            System.out.println("[t2.start 호출] 현재 스레드 = " + Thread.currentThread().getName());
        });

        System.out.println("---- run() 직접 호출 ----");
        t1.run();   // (1)

        System.out.println("---- start() 호출 ----");
        t2.start(); // (2)

        System.out.println("[main] 종료 스레드 = " + Thread.currentThread().getName());
    }
}



실행 예시는 보통 이런 식으로 나온다:

[main] 시작 스레드 = main
---- run() 직접 호출 ----
[t1.run 호출] 현재 스레드 = main
---- start() 호출 ----
[main] 종료 스레드 = main
[t2.start 호출] 현재 스레드 = Thread-1


여기서 바로 핵심이 드러난다.


  t1.run() 을 직접 호출하면
    
      run() 안의 코드가 main 스레드에서 실행된다.
    
  
  t2.start() 를 호출하면
    
      JVM이 새로운 스레드(Thread-1) 를 만들고,
      그 새 스레드에서 run() 이 실행된다.
    
  


즉:


  run()은 “그냥 메서드 호출”이고,

  start()는 “새 스레드를 만들어 그 스레드가 run()을 실행하게 하는 요청”이다.





2. run()은 그냥 “일반 메서드 호출”

run()을 직접 호출했을 때 무슨 일이 일어나는지, 스레드 관점에서만 보자.

Thread t1 = new Thread(() -&gt; {
    System.out.println("[t1.run 호출] 현재 스레드 = " + Thread.currentThread().getName());
});

t1.run();


이건 사실 아래 코드와 아무 차이가 없다:

Runnable r = () -&gt; {
    System.out.println("[t1.run 호출] 현재 스레드 = " + Thread.currentThread().getName());
};

r.run();  // 그냥 메서드 호출


호출 스택은 대략 이렇게 된다:

(main 스레드)
  main()
    └─ t1.run()  // Thread.run() 메서드 호출
          └─ 람다의 run() 코드 실행



  JVM이 새 스레드를 만들지 않는다.
  OS에도 스레드 생성 요청을 보내지 않는다.
  현재 실행 중인 스레드(main)가 그대로 계속해서 run() 코드를 실행할 뿐이다.


그래서 run()을 직접 호출하면,

멀티 스레드 프로그램이 되는 게 아니고,

그냥 “main 스레드가 일을 하나 더 한 것”일 뿐이다.



3. start()는 “새 스레드를 만들어 달라”는 요청

이제 진짜 중요한 부분, start() 안쪽을 보자.

public void start() {
    synchronized (this) {
        // zero status corresponds to state "NEW"
        if (holder.threadStatus != 0)
            throw new IllegalThreadStateException();

        start0();
    }
}



핵심은 딱 세 가지다.


  
    synchronized (this)

    → this(Thread 객체)의 모니터 락을 잡는다.

    
      “지금 이 Thread 인스턴스를 start 중이다” 라는 걸 동기화용으로 표시
      
        동시에 두 스레드가 같은 Thread 인스턴스에 대해 start()를 호출해

        상태가 꼬이는 걸 막기 위한 락이다.
      
      이 락 자체는 스레드를 생성하지 않는다.
        
          “락 획득 = 새 스레드 생성”이 아니다.
          그냥 “이 Thread 객체에 대해 start 작업은 한 번에 하나만” 보장할 뿐이다.
        
      
    
  
  
    if (holder.threadStatus != 0) ...

    → 이 Thread가 이미 시작된 적 있는지 검사한다.

    
      threadStatus == 0 → NEW 상태
      threadStatus != 0 → 이미 한 번 start되었거나, 종료된 스레드
      그래서 Thread는 한 인스턴스를 두 번 이상 start() 할 수 없다.
        
          두 번째부터는 IllegalThreadStateException을 던진다.
        
      
    
  
  
    start0();

    → 여기서부터는 자바가 아니라 네이티브 세계로 넘어간다.

     private native void start0();
    
    

    
      native 키워드는 “이 메서드 구현은 C/C++ 같은 네이티브 코드에 있다”는 뜻이다.
      자바 쪽에는 선언만 있고, 실제 동작은 JVM 내부(C/C++ 코드)에서 한다.
      
        새 스레드를 만들려면 OS API (pthread_create, CreateThread 등)를 써야 하는데,

        그건 자바 코드로는 직접 호출할 수 없다.
      
      
        그래서 start0()에서 JVM의 C/C++ 코드로 넘어가

        → OS 스레드 생성 API를 호출하고

        → 새로 만들어진 OS 스레드에 “이 자바 Thread의 run()을 실행하라”고 연결해준다.
      
    
  


Part 1에서는 여기까지만 본다.

이제부터 나오는 내용( registerNatives(), JVM_StartThread, JavaThread, os::create_thread, pthread_create, thread_entry, Thread.run() 호출)은 Part 2~4에서 단계별로 뜯어볼 것이다.



4. main 스레드 입장에서 본 두 흐름

같은 예제를, 이번에는 “main 스레드 입장”에서 다시 비교해 보자.

4-1. run() 직접 호출 흐름

Thread t1 = new Thread(() -&gt; {
    System.out.println("[t1.run 호출] 현재 스레드 = " + Thread.currentThread().getName());
});

t1.run();



스레드/호출 흐름:

[main 스레드]

main()
 ├─ t1.run() 호출
 │    └─ 람다 run() 실행 (여전히 main 스레드)
 └─ 이후 코드 계속 실행




  main 스레드는 중간에 잠시 t1의 일을 대신 실행했다가,
  일을 끝내고 다시 main 다음 코드로 돌아간다.
  스레드는 여전히 1개 (main) 뿐이다.




4-2. start() 호출 흐름

Thread t2 = new Thread(() -&gt; {
    System.out.println("[t2.start 호출] 현재 스레드 = " + Thread.currentThread().getName());
});

t2.start();



스레드/호출 흐름(개념도):

[main 스레드]                    [새 스레드(Thread-0)]

main()
 ├─ t2.start() 호출
 │    └─ synchronized(this)
 │    └─ 상태 검사(NEW인지)
 │    └─ native start0() 호출
 │         └─ JVM 내부에서 OS에 새 스레드 생성 요청
 │
 └─ 바로 리턴, main의 다음 코드 실행 계속

                               (OS 스케줄러가 Thread-0를 깨움)
                               Thread-0 시작
                               └─ JVM 런타임 엔트리(thread_entry 등)
                                     └─ java.lang.Thread.run()
                                           └─ 람다 run() 코드 실행



정리하면:


  main 스레드
    
      start() 호출만 하고 금방 리턴한다.
      그 후 본인의 일을 계속한다.
    
  
  새 스레드(Thread-0)
    
      OS가 새로 만든 실행 흐름이다.
      JVM 런타임을 통해 최종적으로 Thread.run() → 우리가 넘긴 Runnable.run()을 수행한다.
    
  


이제 프로그램 안에는 동시에 두 개의 스레드(main, Thread-0) 가 돌아가게 된다.

이게 우리가 흔히 말하는 “멀티 스레드” 상태이다.



5. 자주 하는 오해 정리

오해 1. run()을 직접 호출해도 멀티 스레딩이다?

아니다.


  run() 직접 호출 = 해당 메서드가 현재 스레드에서 실행될 뿐이다.
  별도의 스레드를 만들지 않는다.
  call stack 상으로 보면 그냥 “메서드 하나 더 호출했다”와 완전히 동일하다.


멀티 스레딩이 되려면 start()를 통해 JVM이 OS 스레드를 만들도록 해야 한다.



오해 2. synchronized (this) 때문에 스레드가 새로 만들어진다?

아니다.

public void start() {
    synchronized (this) {
        ...
        start0();
    }
}




  synchronized(this) 는 Thread 객체의 모니터 락을 잡을 뿐,
  락을 잡는 행위 자체는 새 스레드를 생성하지 않는다.


역할은 오로지:


  한 Thread 인스턴스에 대해 여러 스레드가 동시에 start()를 호출해도 안전하게 막는 것
  즉, 같은 Thread 객체에 대해 start()가 중복 호출되는 걸 방지하기 위한 동기화.


실제 스레드 생성은 락 안에서 호출하는 start0() 네이티브 메서드에서 일어난다.

(그리고 그 뒤는 Part 2에서 계속…)



오해 3. start()를 여러 번 호출해도 되지 않나?

안 된다.

Thread t = new Thread(() -&gt; { ... });

t.start(); // OK
t.start(); // IllegalThreadStateException




  threadStatus != 0 일 때 예외를 던지도록 코드가 짜여 있다.
  
    한 번 start() 해서 OS 스레드와 매핑되었다가 끝난 Thread 객체는

    “껍데기”만 남는 상태라고 보면 된다.
  
  
    이 객체는 종료 후 상태(TERMINATED)를 확인하거나,

    getState(), getId() 같은 메서드를 호출하는 데에는 쓰일 수 있지만,

    다시 시작하는 건 불가능하다.
  


새로 스레드를 돌리고 싶다면 새 Thread 인스턴스를 만들어야 한다.



6. Part 1 요약 &amp; 다음 글 예고

정리하면:


  run() 직접 호출
    
      그냥 일반 메서드 호출
      현재 스레드(main 등)가 그대로 run() 코드를 실행
      스레드 수는 늘어나지 않는다.
    
  
  start() 호출
    
      JVM 네이티브 코드(start0())로 넘어가 OS 스레드 생성 요청
      새 OS 스레드가 만들어지고, 그 스레드에서 최종적으로 Thread.run()이 실행
      이때부터 진짜 멀티 스레드 환경이 된다.
    
  
  synchronized(this) 는
    
      Thread 객체 단위로 start() 호출을 직렬화하기 위한 락일 뿐,
      스레드 생성과는 직접적인 관련이 없다.
    
  


Part 2에서는 지금 살짝 언급만 했던:


  registerNatives() / JNI,
  start0() 와 JVM_StartThread,
  JavaThread, OSThread 연결,


이 뒤에서 실제로 어떤 코드가 돌아가는지를 “JVM 내부 관점”에서 따라갈 예정이다.

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2025-10-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/monitor-lock-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/monitor-lock-1.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/monitor-lock-1.html"><h1 class="title_post">[Java Concurrency] 모니터 락과 wait/notifyAll로 턴 스케줄러 구현하기</h1></a>
                        <a href="/Java/monitor-lock-1.html" class="txt_post">
                            [Java Concurrency] 모니터 락과 wait/notifyAll로 턴 스케줄러 구현하기

public class StartTest2_2Main {

    //thread1 한 번 -&gt; thread2 한 번 -&gt; thread1 한 번 -&gt; thread2 한 번 -&gt; ...
    //순서 고정

    static final Object TURN_LOCK = new Object();
    static String next = "counter1";

    public static void main(String[] args){
        Thread thread1 = new Thread(new CounterRunnable(),"counter1");
        Thread thread2 = new Thread(new CounterRunnable(),"counter2");
        thread2.start();
        thread1.start();
    }

    static class CounterRunnable implements Runnable {
        public void run(){
            for(int i=1;i&lt;=5;i++){
                try{
                    System.out.println(i+"번째 반복"+Thread.currentThread().getName()+" synchronized 들어가기 전"+ " 모니터락 보유 여부: "+Thread.holdsLock(TURN_LOCK));
                    synchronized(TURN_LOCK){
                        System.out.println(Thread.currentThread().getName()+" synchronized 들어간 후"+ " 모니터락 보유 여부: "+Thread.holdsLock(TURN_LOCK));
                        while(!Thread.currentThread().getName().equals(next)){
                            System.out.println(Thread.currentThread().getName()+" WAIT!"+ " 모니터락 보유 여부: "+Thread.holdsLock(TURN_LOCK));
                            TURN_LOCK.wait();
                            System.out.println(Thread.currentThread().getName()+" WAIT 풀림!"+ " 모니터락 보유 여부: "+Thread.holdsLock(TURN_LOCK));
                        }
                        log("value: "+i);

                        next = next.equals("counter1")?"counter2":"counter1";
                        TURN_LOCK.notifyAll();
                        System.out.println(Thread.currentThread().getName()+" notifyAll() 후"+ " 모니터락 보유 여부: "+Thread.holdsLock(TURN_LOCK));
                    }
                }catch(InterruptedException e){
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
}


코드 분석

의도

두 스레드(counter1, counter2) 가 정해진 순서로 번갈아가며 작업을 수행하도록 만드는 턴 스케줄러를 구현했다.

핵심 요소


  TURN_LOCK: Object 모니터. synchronized(TURN_LOCK)로 임계영역을 보호한다.
    
      모든 객체는 모니터를 가지고 있으므로, 단순히 락 용도로 쓸 객체를 new Object()로 만들었다.
    
  
  next: 이번 턴의 합의된 상태. "counter1" 또는 "counter2" 문자열로 현재 차례를 표현한다.
  while (!Thread.currentThread().getName().equals(next)) { TURN_LOCK.wait(); }
    
      가드 조건. 내 차례가 아니면 곧바로 대기로 전환하고, 깨어난 뒤에도 조건을 반드시 재검사한다.
    
  
  next = ... ? "counter2" : "counter1";
    
      임계영역에서 턴을 전환한다. 다음 차례를 명시적으로 선언한다.
    
  
  TURN_LOCK.notifyAll();
    
      턴을 바꾼 뒤, 같은 모니터의 Wait Set에 있는 모든 스레드를 깨운다.
    
  
  로그
    
      각 지점에서 락 보유 여부를 눈으로 확인하려는 디버깅용 출력이다.
    
  


왜 이 실험을 하는가?


  모니터 모델을 눈으로 확인
    
      “어느 시점에 락을 보유하는지/놓는지” 명확히 보기 위해서
    
  
  notifyAll() 의 의미를 체감
    
      알림은 락을 넘기는 행위기 아님을 확인하고, 알림 뒤에도 실제 실행은 락 재경쟁으로 결정된다는 사실을 출력으로 관찰한다.
    
  
  “스케줄러가 누구에게 CPU를 먼저 주든,최종 순서는 공유 상태가 보장한다”점을 실험으로 증명한다.
    
      운영체제의 스케줄러는 어떤 스레드에게 CPU를 먼저 줄지 전혀 보장하지 않는다.
      예를 들어:
        
          counter1 이 락을 놓자마자 OS가 또 다시 counter1 에게 줄 수도 있고,
          아니면 counter2 에게 바로 CPU를 줄 수 있다.
        
      
      즉, CPU 실행 순서는 비결정적이다.
      CPU를 누가 먼저 차지하든 상관없이, 공유 상태(next)와 가드(while)가 순서를 보장한다는 의미이다.
    
  


결과 분석

1번째 반복counter2 synchronized 들어가기 전 모니터락 보유 여부: false
1번째 반복counter1 synchronized 들어가기 전 모니터락 보유 여부: false
counter2 synchronized 들어간 후 모니터락 보유 여부: true
counter2 WAIT! 모니터락 보유 여부: true
counter1 synchronized 들어간 후 모니터락 보유 여부: true
11:49:28.376 [ counter1] value: 1
counter1 notifyAll() 후 모니터락 보유 여부: true
2번째 반복counter1 synchronized 들어가기 전 모니터락 보유 여부: false
counter2 WAIT 풀림! 모니터락 보유 여부: true
11:49:28.384 [ counter2] value: 1
counter2 notifyAll() 후 모니터락 보유 여부: true
2번째 반복counter2 synchronized 들어가기 전 모니터락 보유 여부: false
counter2 synchronized 들어간 후 모니터락 보유 여부: true
counter2 WAIT! 모니터락 보유 여부: true
counter1 synchronized 들어간 후 모니터락 보유 여부: true
11:49:28.386 [ counter1] value: 2
counter1 notifyAll() 후 모니터락 보유 여부: true
3번째 반복counter1 synchronized 들어가기 전 모니터락 보유 여부: false
counter1 synchronized 들어간 후 모니터락 보유 여부: true
counter1 WAIT! 모니터락 보유 여부: true
counter2 WAIT 풀림! 모니터락 보유 여부: true
11:49:28.386 [ counter2] value: 2
counter2 notifyAll() 후 모니터락 보유 여부: true
3번째 반복counter2 synchronized 들어가기 전 모니터락 보유 여부: false
counter2 synchronized 들어간 후 모니터락 보유 여부: true
counter2 WAIT! 모니터락 보유 여부: true
counter1 WAIT 풀림! 모니터락 보유 여부: true
11:49:28.388 [ counter1] value: 3
counter1 notifyAll() 후 모니터락 보유 여부: true
4번째 반복counter1 synchronized 들어가기 전 모니터락 보유 여부: false
counter2 WAIT 풀림! 모니터락 보유 여부: true
11:49:28.389 [ counter2] value: 3
counter2 notifyAll() 후 모니터락 보유 여부: true
4번째 반복counter2 synchronized 들어가기 전 모니터락 보유 여부: false
counter1 synchronized 들어간 후 모니터락 보유 여부: true
11:49:28.390 [ counter1] value: 4
counter1 notifyAll() 후 모니터락 보유 여부: true
5번째 반복counter1 synchronized 들어가기 전 모니터락 보유 여부: false
counter1 synchronized 들어간 후 모니터락 보유 여부: true
counter1 WAIT! 모니터락 보유 여부: true
counter2 synchronized 들어간 후 모니터락 보유 여부: true
11:49:28.391 [ counter2] value: 4
counter2 notifyAll() 후 모니터락 보유 여부: true
5번째 반복counter2 synchronized 들어가기 전 모니터락 보유 여부: false
counter2 synchronized 들어간 후 모니터락 보유 여부: true
counter2 WAIT! 모니터락 보유 여부: true
counter1 WAIT 풀림! 모니터락 보유 여부: true
11:49:28.398 [ counter1] value: 5
counter1 notifyAll() 후 모니터락 보유 여부: true
counter2 WAIT 풀림! 모니터락 보유 여부: true
11:49:28.398 [ counter2] value: 5
counter2 notifyAll() 후 모니터락 보유 여부: true


1. 이 실행에서는 우연히 counter2가 먼저 for 루프에 진입했고, 그 다음에 counter1이 진입 (실제로는 매 실행마다 순서가 달라질 수 있다.)

1번째 반복counter2 synchronized 들어가기 전 모니터락 보유 여부: false
1번째 반복counter1 synchronized 들어가기 전 모니터락 보유 여부: false


2. counter2가 먼저 들어왔으니 TURN_LOCK 객체의 모니터락을 잡고 synchronized(){} 문 안으로 들어감

counter2 synchronized 들어간 후 모니터락 보유 여부: true


3.  counter2가 조건에 맞아 while문에 들어감 → wait 상태 들어감

counter2 WAIT! 모니터락 보유 여부: true



  wait()를 호출한 시점 이후의 코드는, 스레드가 다시 깨워져서 락을 재획득할 때까지 실행되지 않는다.


4. counter1이 모니터 락을 잡아서 synchronized{} 문 안으로 들어감→ while 조건 해당을 만족하지 않으므로 진입하지 않음 → log 출력

counter1 synchronized 들어간 후 모니터락 보유 여부: true
11:49:28.376 [ counter1] value: 1



5. log를 출력하고 잠들어 있는 스레드들을 깨움 (하지만 아직 락은 counter1이 가지고 있음)

counter1 notifyAll() 후 모니터락 보유 여부: true


6. counter1 이 첫 번째 반복문이 끝나고 두 번째 반복문을 돈다(모니터락 보유 여부 : false)

2번째 반복counter1 synchronized 들어가기 전 모니터락 보유 여부: false


7. counter2가 모니터 락을 잡아서 다시 wait() 뒤부터 시작 → while 문에서 탈출하여 log 출력( next 필드 값 변경했기 때문에 탈출)

counter2 WAIT 풀림! 모니터락 보유 여부: true
11:49:28.384 [ counter2] value: 1



8. counter2이 첫 번째 반복문 끝나고 두 번째 반복문 돔(모니터락 보유 여부 : false)

counter2 notifyAll() 후 모니터락 보유 여부: true
2번째 반복counter2 synchronized 들어가기 전 모니터락 보유 여부: false



  이때 wait() 중인 스레드가 없기 때문에, notifyAll() 호출은 실질적으로 깰 대상이 없다.
  만약 counter1이 모니터락을 잡고 먼저 들어왔다면 while 문에서 wait() 상태로 있었을 것


9. 다시 counter2가 모니터락 잡음 ( notifyAll()로 깨워도 잡기 위해서 경쟁해야함)

counter2 synchronized 들어간 후 모니터락 보유 여부: true


10. 다시 순서는 counter1부터 시작해야하므로 counter2는 wait 상태로 전환

counter2 WAIT! 모니터락 보유 여부: true
counter1 synchronized 들어간 후 모니터락 보유 여부: true


11. 반복문이 끝날 때까지 위의 과정 반복

주의사항

1. if가 아닌 while 은 필수


  
    경쟁 상황(race)과 notifyAll()

    notifyAll()은 여러 스레드를 동시에 깨운다. 깬 다음 락을 누가 먼저 잡느냐는 운이다. 내가 먼저 깼지만, 락을 잡았을 때는 이미 다른 스레드가 상태(next)를 바꿔서 내 차례가 아닐 수 있다. 그래서 깬 뒤에도 “정말 내 차례인가?”를 재확인해야 한다.
  



  모니터락 권한을 얻으면 얻은 스레드는 wait(); 이후 코드부터 실행
  if문은 그전에 검사했기 때문에 바로 탈출
  스레드가 여러 개 일 때 자신의 차례가 아니여도 뒤의 코드를 실행할 수 있음
    
      (자신의 차례가 맞는지 확인하기 위해서 while()로 조건 다시 검사하는 것
    
  


2. notifyAll()은 모니터 락을 바로 부여하는 것이 아님


  TURN_LOCK.notifyAll() 을 호출하면, WAIT 중이던 스레드들을 깨우기만 한다.
  하지만 아직은 현재 스레드가 TURN_LOCK 을 가지고 있으므로, 깨어난 스레드들은 실행하지 못하고 “락을 달라”면서 대기 상태가 된다.
  현재 스레드가 블록을 벗어나면서 TURN_LOCK 모니터 락을 놓는다.
  그 순간, notifyAll() 으로 깨어나 대기 중이던 스레드 중 하나가 락을 얻어 실행을 재개한다.
  락을 얻은 스레드의 재개 지점은 wait() 가 끝난 곳(즉, wait() 호출 바로 다음 줄) 부터이다.


3. notifyAll()은 대기 큐에 있는 스레드들을 깨움


  wait()를 호출한 스레드는 RUNNABLE 상태가 아니라, WAITING 상태로 바뀌어서 TURN_LOCK의 wait set(대기 집합, 큐) 에 들어가게 된다.
  notifyAll() 은 이 wait set에 들어가 있는 모든 스레드를 깨우는 것이다.


대기 큐는 어디 있나?


  각 객체(TURN_LOCK 같은 Object)는 JVM 안에서 하나의 모니터를 갖는다.
  이 모니터에는 크게 두 가지 내부 자료구조가 있다
    
      Entry Set: synchronized 블록 안에 들어가려고 락을 기다리는 스레드들의 집합 (항상 경쟁 상태)
      Wait Set: 이미 락을 가지고 있는 스레드가 wait()를 호출하면서 자발적으로 락을 내려놓고 들어가는 대기 집합 (비활성 대기)
    
  
  Entry Set은 락을 얻기 위해 경쟁하는 것이고 Wait Set은 경쟁하는 것이 아닌 락을 내려놓고 스스로 잠드는 상태
    
      Wait Set이 notifyAll() 을 통해서 깨어나야지 락을 얻기 위해 경쟁하는 것
    
  


4. counter1이 synchronized 블록을 빠져나온 뒤, 다음 반복에서 락을 다시 먼저 획득 할 수도 있다.

12:33:29.027 [ counter1] value: 3
counter1 notifyAll() 후 모니터락 보유 여부: true
4번째 반복counter1 synchronized 들어가기 전 모니터락 보유 여부: false
counter1 synchronized 들어간 후 모니터락 보유 여부: true
counter1 WAIT! 모니터락 보유 여부: true
counter2 synchronized 들어간 후 모니터락 보유 여부: true
12:33:29.028 [ counter2] value: 3



  notifyAll()은 깨우기만 하고, 락 소유권을 특정 스레드에 양도하지 않는다.
  “락은 synchronized 블록이 끝날 때 해제되고, 그 때 Entry Set + Wait Set에서 깨어난 스레드들이 다 같이 경쟁해서 한 스레드가 다시 얻는다.
  위의 코드에서 처럼
    
      방금 블록을 빠져나온 counter1
      wait() 에서 깨워져 경쟁에 합류한 counter2
      경쟁해서 counter1 이 다시 들어갔다.
    
  


코드가 안전하게 counter1 → counter2→counter1 → counter2 로 찍히는 이유


  턴 스위치


next = next.equals("counter1") ? "counter2" : "counter1";



  가드 조건(반드시 while)


while (!Thread.currentThread().getName().equals(next)) {
    TURN_LOCK.wait();
}


                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2025-09-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/thread-monitor-lock-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/thread-monitor-lock-1.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/thread-monitor-lock-1.html"><h1 class="title_post">[Java Concurrency] Thread.start()와 Thread 객체의 모니터 락 획득 과정</h1></a>
                        <a href="/Java/thread-monitor-lock-1.html" class="txt_post">
                            [Java Concurrency] Thread.start()와 Thread 객체의 모니터 락 획득 과정

글을 읽기 전 알아야 할 개념

1. 모니터 락(Monitor Lock):

Java에서 synchronized() 키워드를 쓸 때 사용되는 잠금 메커니즘


  자바의 모든 객체는 하나의 모니터(Monitor)를 가지고 있다.
    
      HotSpot JVM은 매 객체에 실물 ObjectMonitor를 항상 붙여두지 않고, 필요할 때(경합 발생 등) 만든다. “모니터를 가진다”는 개념/논리적인 표현이다.
    
  
  이 모니터는 일종의 “잠금 장치”로, 여러 스레드가 동시에 객체에 접근할 때 한 번에 하나의 스레드만 들어올 수 있도록 관리한다.
  Thread도 하나의 객체이므로 모니터 락을 가지고 있다.


모니터 메타데이터에 들어있는 정보


  현재 락을 소유한 스레드(Owner)
  재진입 횟수(한 스레드가 몇 번 중첩해서 진입했는지)
  대기 중인 스레드 목록


ObjectMonitor 코드

ObjectMonitor는 hotspot/src/share/vm/runtime/objectMonitor.hpp 파일에 정의되어 있습니다.

// hotspot/src/share/vm/runtime/objectMonitor.hpp

class ObjectMonitor {
  // 필드들은 실제로는 private 이지만 설명을 위해 단순화
  public:
    // 1. 객체 헤더와의 연결
    volatile markWord _header;       // 객체의 마크 워드(markWord)를 저장

    // 2. 락 소유 정보
    void* volatile _owner;           // 현재 락을 소유한 스레드의 포인터 (OSThread*)
    volatile intptr_t  _recursions;  // 재진입 횟수. _owner 스레드가 락을 중첩해서 잡은 횟수

    // 3. 스레드 대기 큐 (가장 중요)
    ObjectWaiter* volatile _EntryList; // 락을 얻기 위해 대기하는 스레드 목록 (블록된 스레드)
    ObjectWaiter* volatile _WaitSet;   // object.wait() 호출로 대기 중인 스레드 목록
};

// 스레드 대기 목록을 구성하는 노드
class ObjectWaiter {
  public:
    ObjectWaiter* _next;   // 다음 대기자를 가리키는 포인터
    ObjectWaiter* _prev;   // 이전 대기자를 가리키는 포인터
    Thread* _thread; // 대기 중인 스레드
    // ...
};


2. Thread 객체 vs 실행 단위 관계


  Thread 객체는 자바 코드 안에서 스레드를 제어하는 껍데기(핸들)이다.
  실행 단위는 실제로 CPU에서 동작하는 작업(명령어) 흐름이다. 운영체제 스레드(플랫폼 스레드)거나, JVM이 관리하는 가상 스레드일 수 있다.
  
    JVM이 둘을 연결시켜 줘야 동작할 수 있다.

    실행 단위(실행 흐름)는 CPU에서 명령어가 순차적으로 실행되는 “흐름”일 뿐이다.
자체로는 상태를 기억하거나 이름이 붙어 있지 않고, 단지 코드를 실행하는 역할만 한다.
개발자는 그 흐름을 중단, 재개, 이름 확인, 상태 확인 같은 제어를 하고 싶기 때문에 객체(Thread)를 만들어서 그 실행 흐름을 가리키는 핸들 역할을 시키는 것이다.
  
  한 실행 단위 스레드가 만들어질 때, 무조건 대응되는 Thread 객체가 하나 생긴다.
  즉. 1 실행 단위 ⇒ 1 Thread 객체 매핑
  단, Thread 객체 생성(new)만으로는 실행 단위가 생기지 않는다. 반드시 start()가 호출되어야 JVM이 실행 단위를 붙여준다.


new로 Thread 객체를 생성한 시점에는 객체(껍데기)만 존재한다.

start() 가 호출되면 실행 흐름이 생성되고 객체와 1:1로 연결된다.

스레드가 종료되면 실행 흐름은 사라지고, 객체는 상태(Terminated 등)와 식별 정보를 간직하게 된다.

3. synchronized(this)

자바에서 동기화 블록을 만들 때 쓰는 키워드


  모니터 락(monitor lock)을 얻어서 동시에 단 하나의 스레드만 코드 블록에 들어오게 보장하는 장치
  synchronized(this)라고 했을 때, 락은 현재 인스턴스의 모니터에 걸린다.
  락은 특정 객체 단위로 존재한다. synchronized(obj)라고 쓰면, 스레드가  obj(여기서는 Thread 객체)에 달린 모니터를 얻어야만 블록 안으로 들어올 수 있다.


Thread.start() 코드

//Thread.start() 내부 코드
public void start() {  
		synchronized (this) {
		    // zero status corresponds to state "NEW"   
		    if (holder.threadStatus != 0)        
		        throw new IllegalThreadStateException();   
        start0();             
    }
}

// ※ JDK 버전에 따라 구현은 조금씩 다르다.


스레드가 스레드 객체의 모니터 락을 얻는 과정


  스레드가 synchronized(obj) 블록에 들어가려면, JVM은 내부적으로 obj(여기서는 Thread 객체) 의 모니터 락이 비어 있는지 확인한다.
  비어 있으면 현재 스레드가 락을 차지하고 블록 안으로 들어간다.
  이미 다른 스레드가 소유 중이면, 대기 상태에 들어가고 락이 해제될 때까지 기다린다.
  락 소유 정보는 Thread 인스턴스 안에 기록되는 것이 아닌, JVM 내부 모니터 구조체(ObjectMonitor)에 기록된다.
  그 구조체에 “현재 이 모니터(Thread 객체 내 모니터)를 소유한 스레드 ID”가 저장된다.


synchronized(this) 블록: 오직 한 명만 들어갈 수 있는 ‘특별한 방’

Thread 객체 (this): 그 방에 들어갈 수 있는 ‘단 하나의 열쇠(모니터 락)’를 가지고 있는 주체. 이 열쇠는 객체가 생성될 때부터 부여된다.

Thread 실행 흐름: 그 방에 들어가서 일을 해야 하는 ‘일꾼’

Thread 객체의 락이 필요한 이유


  Thread.start() 는 동일한 스레드 객체에 대해 여러 번 start() 를 호출하면 안 된다는 제약이 있다.


Thread t = new Thread(...);
t.start();
t.start(); // IllegalThreadStateException 발생해야 함



  이런 상황을 막으려면, 여러 스레드가 동시에 같은 Thread 객체의 start()를 호출할 수 없도록 락을 걸어야 한다.


주의사항

락이 Thread 객체 자체에 걸린다?


  synchronized(this)라고 했을 때, 락은 그 Thread 객체의 모니터에 걸린다. 이는 ‘객체 전체 접근 금지’ 가 아니라 ‘그 모니터를 기준으로 한 임계 구역 보호’만 의미한다.
  그래서 이 코드 블록에 들어가려면 obj의 모니터 락을 먼저 획득해야 한다는 조건이 생기는 것이다.
  실제로 막히는 건 synchronized(this) 블록 안의 코드 실행이다.
  락이 걸려 있어도 다른 스레드가 obj.toString(), obj.hashCode() 같은 동기화되지 않은 메서드를 호출하거나, obj를 일반 변수로 읽어오는 건 가능하다.
  단지 synchronized(obj) 로 보호된 임계 구역에는 동시에 두 개 이상의 스레드가 못 들어올 뿐이다.


락 소유 정보는 객체가 가지고 있나?


  락 소유 정보는 JVM 내부의 ObjectMonitor 구조체에 기록된다.


                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2025-09-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>

    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture > api-design",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/api-design/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture > data-modeling-erd",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/data-modeling-erd/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture > security-auth",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/security-auth/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture > system-design",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/system-design/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Spring Boot > Security",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Spring%20Boot/Security/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Spring Boot",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Spring%20Boot/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Trouble Shooting",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Trouble%20Shooting/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "[Java Concurrency] Thread.start()와 Thread 객체의 모니터 락 획득 과정",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, Concurrency, monitor lock, thread, synchronized, multi thread",
            'url'      : "/Java/thread-monitor-lock-1.html",
            'image'    : "/assets/img/thumbnail/thread-monitor-lock-1.png",
            'date'     : "2025-09-26"
        });
    

        posts.push({
            'title'    : "[Java Concurrency] 모니터 락과 wait/notifyAll로 턴 스케줄러 구현하기",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, Concurrency, monitor lock, wait-notifyAll",
            'url'      : "/Java/monitor-lock-1.html",
            'image'    : "/assets/img/thumbnail/monitor-lock-1.png",
            'date'     : "2025-09-30"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part1-start-vs-run-code-and-flow.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-02"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] Part 2 – Thread.start() 뒤에서 일어나는 일: registerNatives ~ JVM_StartThread ~ JavaThread",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part2-start0-jvm-startthread-javathread.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-03"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part3-os-create-thread-pthread-glibc-clone.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-04"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] Part 4 – 새로운 스레드가 자바 run()에 도달하기까지: thread_native_entry → JavaThread::run → thread_entry → Thread.run()",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part4-thread-entry-to-run.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-04"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] 마지막 글 - 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part5-thread-lifecycle-summary.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-06"
        });
    

        posts.push({
            'title'    : "[Firebase/Java] Firestore ApiFuture와 Java Future, 그리고 Reactor Mono까지 – 비동기 흐름 뜯어보기",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, firestore, apifuture, future, listenablefuture, reactor, mono, async, concurrency",
            'url'      : "/Java/firestore-apifuture-future-mono-async-flow.html",
            'image'    : "/assets/img/thumbnail/firestore-apifuture-future-mono-async-flow.png",
            'date'     : "2025-10-25"
        });
    

        posts.push({
            'title'    : "[시스템 설계] 하루 한 번 알림을 “누락 없이” 보내기 위한 Redis 큐 &amp; 워커 설계",
            'path'     : "Architecture > system-design",
            'type'     : "post",
            'tags'     : "redis, worker, at-least-once-notification, spring schedule, blmove, redis-queue-blmove-idempotency",
            'url'      : "/Architecture/system-design/at-least-once-notification-redis-queue-blmove-idempotency.html",
            'image'    : "/assets/img/thumbnail/at-least-once-notification-redis-queue-blmove-idempotency.png",
            'date'     : "2025-11-03"
        });
    

        posts.push({
            'title'    : "카카오 OAuth 로그인 흐름 이해하기: JS SDK + Authorization Code 플로우",
            'path'     : "Architecture > security-auth",
            'type'     : "post",
            'tags'     : "springboot, spring-security, oauth2, kakao, login, diagram",
            'url'      : "/Architecture/security-auth/2025-11-30-kakao-login.html",
            'image'    : "/assets/img/thumbnail/2025-11-30-kakao-login.png",
            'date'     : "2025-11-30"
        });
    

        posts.push({
            'title'    : "[Docker Troubleshooting] Spring Redis UnknownHostException 해결기: Spring 앱과 Redis의 외부 네트워크와 DNS 스코프 문제",
            'path'     : "Trouble Shooting",
            'type'     : "post",
            'tags'     : "docker, docker-compose, redis, spring, networking, dns, ec2, devops, troubleshooting",
            'url'      : "/Trouble%20Shooting/docker-redis-network-dns.html",
            'image'    : "/assets/img/thumbnail/docker-redis-network-dns.png",
            'date'     : "2025-12-08"
        });
    

    searchPost(posts);

    
</script>
    <script type="module">
        import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
        document.addEventListener("DOMContentLoaded", function () {
            mermaid.initialize({ startOnLoad: true });
        });
    </script>
</html>
