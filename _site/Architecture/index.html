<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Architecture
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | Gimin’s Blog</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="시스템 설계와 깊게 공부하는 것을 좋아하는 개발자의 블로그입니다.">
<meta property="og:description" content="시스템 설계와 깊게 공부하는 것을 좋아하는 개발자의 블로그입니다.">
<link rel="canonical" href="http://localhost:4000/Architecture/">
<meta property="og:url" content="http://localhost:4000/Architecture/">
<meta property="og:site_name" content="Gimin’s Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:02:36+08:27">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"1900-01-01T00:02:36+08:27","datePublished":"1900-01-01T00:02:36+08:27","description":"시스템 설계와 깊게 공부하는 것을 좋아하는 개발자의 블로그입니다.","headline":"Index","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Architecture/"},"url":"http://localhost:4000/Architecture/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="시스템 설계와 깊게 공부하는 것을 좋아하는 개발자의 블로그입니다.">

        <link rel="preload" href="/assets/img/profile.jpg" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>Gimin's Blog</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/profile.jpg" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    
            
            
            
            
            
            
            
            
            
            
            
            
            
            

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="Architecture">
            <div class="nav-item">
                <a href="/Architecture/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Architecture</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Architecture category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="Domain Design">
                    <div class="nav-item">
                        <a href="/Architecture/Domain%20Design/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Domain Design</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="System Design">
                    <div class="nav-item">
                        <a href="/Architecture/System%20Design/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>System Design</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="data-modeling-erd">
                    <div class="nav-item">
                        <a href="/Architecture/data-modeling-erd/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>data-modeling-erd</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="security-auth">
                    <div class="nav-item">
                        <a href="/Architecture/security-auth/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>security-auth</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Java">
            <div class="nav-item">
                <a href="/Java/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Java</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="Spring Boot">
            <div class="nav-item">
                <a href="/Spring%20Boot/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Spring Boot</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Spring Boot category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="Security">
                    <div class="nav-item">
                        <a href="/Spring%20Boot/Security/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Security</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Trouble Shooting">
            <div class="nav-item">
                <a href="/Trouble%20Shooting/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Trouble Shooting</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/Gimini-3">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:gimin1463@naver.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                
                
                    <li><a aria-label="My Instagram" href="https://www.instagram.com/gimin0226">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"></path></svg>
                    </a></li>
                
                
                
                    <li><a aria-label="My LinkedIn" href="https://www.linkedin.com/in/g-m-627b33392">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg>
                    </a></li>
                
            </ul>
            <hr>
            <span>
                Copyright © 2024 | <a href="https://github.com/byanko55/jekyll-theme-satellite">Yankos</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>

        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            
                
                    Architecture
                
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        Architecture
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Architecture/Domain%20Design/oneco-ddd-dailycontent-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/oneco-ddd-dailycontent.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Architecture/Domain%20Design/oneco-ddd-dailycontent-2.html"><h1 class="title_post">[ONECO DDD 도메인 설계 시리즈 Part 2] DailyContent 애그리거트 뜯어보기</h1></a>
                        <a href="/Architecture/Domain%20Design/oneco-ddd-dailycontent-2.html" class="txt_post">
                            [ONECO DDD 도메인 설계 시리즈 Part 2] DailyContent 애그리거트 뜯어보기


  Part 1에서는 “왜 DailyContent를 애그리거트 루트로 두었는가”를 개념적으로 정리했다면,
이번 Part 2는 실제 코드 한 파일(DailyContent.java)(애그리거트)을 기준으로 설계 의도와 동작 방식을 해부하는 글이다.





0. 도메인 구조 &amp; 전체 코드 원문

먼저 기준이 되는 DailyContent 애그리거트 전체 코드이다.

(프로젝트를 진행하며 수정되거나 추가될 수도 있다. 수정된 코드는 깃허브에서 확인할 수 있다.)

@Entity
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Table(name = "daily_contents",
    uniqueConstraints = {
        @UniqueConstraint(
            name= "uk_category_day_sequence",
            columnNames = {"category_id", "day_sequence"}
        )
    })
public class DailyContent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Embedded
    private CategoryId categoryId;

    @Convert(converter = DaySequenceConverter.class)
    private DaySequence daySequence;

    @Embedded
    private ContentDescription description;

    @Embedded
    private Keyword keyword;

    @Embedded
    @AttributeOverride(name = "url", column = @Column(name = "image_url", nullable = false))
    private ImageFile imageFile;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "daily_content_id", nullable = false)
    private List&lt;NewsItem&gt; newsItems = new ArrayList&lt;&gt;();

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "daily_content_id", nullable = false)
    private List&lt;Quiz&gt; quizzes = new ArrayList&lt;&gt;();

    private DailyContent(
        CategoryId categoryId,
        DaySequence daySequence,
        Keyword keyword,
        ContentDescription description,
        ImageFile imageFile
    ) {
        if(categoryId == null) {
            throw new IllegalArgumentException("categoryId는 null일 수 없습니다.");
        }
        if(daySequence == null) {
            throw new IllegalArgumentException("daySequence는 null일 수 없습니다.");
        }
        if(keyword == null) {
            throw new IllegalArgumentException("keyword는 null일 수 없습니다.");
        }
        if(description == null) {
            throw new IllegalArgumentException("description는 null일 수 없습니다.");
        }
        if(imageFile == null) {
            throw new IllegalArgumentException("imageFile는 null일 수 없습니다.");
        }
        this.categoryId = categoryId;
        this.daySequence = daySequence;
        this.keyword = keyword;
        this.description = description;
        this.imageFile = imageFile;
    }

    public static DailyContent create(
        CategoryId categoryId,
        DaySequence daySequence,
        Keyword keyword,
        ContentDescription description,
        ImageFile imageFile
    ) {
        return new DailyContent(categoryId, daySequence, keyword, description, imageFile);
    }

    public void updateDescription(ContentDescription newDescription) {
        Objects.requireNonNull(newDescription, "newDescription은 null일 수 없습니다.");
        this.description = newDescription;
    }

    public void changeSummary(String newSummary) {
        this.description = this.description.withSummary(newSummary);
    }

    public void changeTitle(String newTitle){
        this.description = this.description.withTitle(newTitle);
    }

    public void changeBodyText(String newBodyText) {
        this.description = this.description.withBodyText(newBodyText);
    }

    public List&lt;NewsItem&gt; getNewsItems(){
        return List.copyOf(newsItems);
    }

    public void updateNewsTitle(NewsItemOrder order, String newTitle) {
        NewsItem target = this.newsItems.stream()
            .filter(item -&gt; item.getNewsItemOrder().equals(order))
            .findFirst()
            .orElseThrow(() -&gt; new IllegalArgumentException("해당 순번의 뉴스가 존재하지 않습니다."));

        target.changeTitle(newTitle);
    }

    public void updateQuizQuestion(QuestionOrder order, String newQuestion) {
        Quiz target = this.quizzes.stream()
            .filter(q -&gt; q.getQuestionOrder().equals(order))
            .findFirst()
            .orElseThrow(() -&gt; new IllegalArgumentException("해당 순번의 퀴즈가 존재하지 않습니다."));

        target.changeQuestion(newQuestion);
    }

    public NewsItem addNewsItem(
        String title,
        NewsItemOrder order,
        WebLink link,
        ImageFile imageFile
    ) {
        Objects.requireNonNull(title, "title은 null일 수 없다.");
        Objects.requireNonNull(order, "order는 null일 수 없다.");
        Objects.requireNonNull(imageFile, "imageFile은 null일 수 없다.");
        Objects.requireNonNull(link, "link는 null일 수 없다.");

        validateNewsOrderDuplicate(order);

        NewsItem item = NewsItem.create(title, link, order, imageFile);
        newsItems.add(item);
        return item;
    }

    public void removeNewsItem( NewsItem item) {
        if (item ==null) {
            throw new IllegalArgumentException("뉴스 아이템은 null일 수 없습니다.");
        }
        newsItems.remove(item);
    }

    public void removeNewsItemByOrder(NewsItemOrder order) {
        boolean removed = this.newsItems.removeIf(item -&gt; item.getNewsItemOrder().equals(order));
        if (!removed) {
            throw new IllegalArgumentException("삭제할 뉴스가 존재하지 않습니다.");
        }
    }

    public void changeKeyword(Keyword newKeyword) {
        Objects.requireNonNull(newKeyword, "newKeyword는 null일 수 없다.");
        this.keyword = newKeyword;
    }

    public void changeImage(ImageFile newImageFile) {
        Objects.requireNonNull(newImageFile, "newImageFile는 null일 수 없다.");
        this.imageFile = newImageFile;
    }

    public boolean isSameCategory(CategoryId other) {
        return this.categoryId.equals(other);
    }

    public List&lt;Quiz&gt; getQuizzes(){
        return List.copyOf(quizzes);
    }

    public Quiz addQuiz(
        String question,
        QuestionOrder order,
        QuizOptions options,
        AnswerIndex answerIndex
    ) {
        Objects.requireNonNull(question, "question은 null일 수 없다.");
        Objects.requireNonNull(order, "order는 null일 수 없다.");
        Objects.requireNonNull(options, "options는 null일 수 없다.");
        Objects.requireNonNull(answerIndex, "answerIndex는 null일 수 없다.");

        validateQuizOrderDuplicate(order);

        Quiz quiz = Quiz.create(question, order, options, answerIndex);
        quizzes.add(quiz);
        return quiz;
    }

    public void removeQuiz( Quiz quiz) {
        if (quiz ==null) {
            throw new IllegalArgumentException("퀴즈는 null일 수 없습니다.");
        }
        quizzes.remove(quiz);
    }

    public void removeQuizByOrder(QuestionOrder order) {
        boolean removed = this.quizzes.removeIf(q -&gt; q.getQuestionOrder().equals(order));
        if (!removed) {
            throw new IllegalArgumentException("삭제할 퀴즈가 존재하지 않습니다: " + order.value());
        }
    }

    private void validateNewsOrderDuplicate(NewsItemOrder order) {
        if (newsItems.stream().anyMatch(n -&gt; n.getNewsItemOrder().equals(order))) {
            throw new IllegalArgumentException("동일한 뉴스 순번이 이미 존재합니다: " + order.value());
        }
    }

    private void validateQuizOrderDuplicate(QuestionOrder order) {
        if (quizzes.stream().anyMatch(q -&gt; q.getQuestionOrder().equals(order))) {
            throw new IllegalArgumentException("동일한 퀴즈 순번이 이미 존재합니다: " + order.value());
        }
    }
}



이제 이 코드를 “애그리거트 루트로서 어떤 책임을 갖고 있는지” 관점에서 단계적으로 살펴본다.



1. 애그리거트 @Entity, @Table, 유니크 제약

@Entity
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Table(name = "daily_contents",
uniqueConstraints = {
@UniqueConstraint(
name= "uk_category_day_sequence",
columnNames = {"category_id", "day_sequence"}
)
})
public class DailyContent { ... }


여기에는 세 가지 의도가 들어 있다.


  
    @Entity + @Table(name = "daily_contents")

    도메인 이름은 DailyContent지만, 테이블은 daily_contents 로 복수형 snake_case를 사용했다.

    스키마만 열어봐도 “여러 개의 DailyContent가 모여 있는 테이블”이라는 사실을 직관적으로 알 수 있게 하기 위한 선택이다.
  
  
    @NoArgsConstructor(access = PROTECTED)

    JPA가 리플렉션으로 인스턴스를 만들 수 있도록 기본 생성자는 열어두되,

    애플리케이션 코드에서 무분별하게 new DailyContent() 하지 못하도록 보호한다.

    실제 생성 경로는 아래에서 볼 create(...) 팩토리로만 강제된다.
  
  
    @UniqueConstraint(category_id, day_sequence)

    (카테고리, 일차) 조합이 유일해야 한다는 비즈니스 규칙을 DB까지 내리는 선택이다.

    
      도메인 규칙: “카테고리 A의 3일차 DailyContent는 단 하나만 존재한다.”
      이 규칙을 RDB의 유니크 키로 함께 보강함으로써, 애플리케이션 버그나 동시성 이슈로 인한 중복 생성도 차단한다.
    
  


DDD 관점에서 보면, 애그리거트 루트의 핵심 불변식 하나를 데이터베이스에 위임한 형태이다.



2. 하루치 학습 경험을 표현하는 값 객체들

DailyContent는 원시 타입을 거의 사용하지 않고 대부분을 VO로 감싼다.

@Embedded
private CategoryId categoryId;

@Convert(converter = DaySequenceConverter.class)
private DaySequence daySequence;

@Embedded
private ContentDescription description;

@Embedded
private Keyword keyword;

@Embedded
@AttributeOverride(name = "url", column = @Column(name = "image_url", nullable = false))
private ImageFile imageFile;



각 VO의 역할은 다음과 같다.

2.1 CategoryId


  단순 Long categoryId 대신 CategoryId VO 사용.
  값 생성 시 “양수인지, null 아닌지”를 VO 내부에서 보장한다.
  다른 애그리거트(카테고리)와 연결되는 키이기도 하기 때문에, 의미 있는 타입으로 감싸 검증 포인트를 한 곳에 모았다.


2.2 DaySequence


  “이 카테고리에서 몇 번째 날인지(1일차, 2일차…)” 를 표현하는 타입.
  AbstractSequence를 상속하여 “1 이상”이라는 공통 규칙을 재사용한다.
  JPA 매핑은 @Convert(converter = DaySequenceConverter.class) 를 통해 INT 한 컬럼으로 저장한다.
  도메인 코드에서는 항상 DaySequence 타입으로 다룸으로써, 날짜/일차 개념이 섞이지 않도록 한다.


2.3 ContentDescription


  title, summary, bodyText 를 하나의 VO로 묶었다.
  길이 제한, 공백 허용 여부, null 불가 등의 검증은 모두 VO 생성 시점에 수행된다.
  DailyContent는 “설명 자체가 null인지” 정도만 체크하고, 문자열 유효성은 VO에 위임한다.


2.4 Keyword


  오늘의 핵심 키워드(예: “기준금리”, “양적완화”)를 표현한다.
  최대 길이, 공백 제거(trim), 빈 문자열 방지 등의 검증을 VO 내부에서 수행한다.


2.5 ImageFile


  대표 이미지에 대한 url을 표현하는 VO.
  지금은 url 한 개만 갖지만, 나중에 “허용 도메인, 허용 확장자, 규격” 같은 정책을 추가할 때도 이 타입 안에서 일관되게 처리할 수 있다.


요약

DailyContent는 “하루치 학습 경험”을 구성하는 요소들을 전부 의미 있는 타입(VO)으로 받고,

각 VO는 “자기 값은 자기 책임으로 검증하는” 구조를 가진다.

애그리거트 루트는 값의 조합과 일관성에 집중하고, 값 자체의 정합성은 VO 레벨에서 담당한다.



3. NewsItem / Quiz 컬렉션: 애그리거트 내부 엔티티 관리

@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
@JoinColumn(name = "daily_content_id", nullable = false)
private List&lt;NewsItem&gt; newsItems = new ArrayList&lt;&gt;();

@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
@JoinColumn(name = "daily_content_id", nullable = false)
private List&lt;Quiz&gt; quizzes = new ArrayList&lt;&gt;();



여기에는 애그리거트 생명주기와 관련된 설계 의도가 들어 있다.

부모 자체를 삭제하면 cascade, 컬렉션에서 자식만 빼면 orphanRemoval이 동작한다.

3.1 cascade = CascadeType.ALL


  DailyContent를 저장/삭제할 때, 관련된 NewsItem/Quiz도 함께 저장/삭제된다.
  즉, “하루치 콘텐츠”의 생명주기에 뉴스·퀴즈를 묶는다.
  DDD 용어로, NewsItem과 Quiz는 같은 애그리거트에 속한 엔티티이며, 루트인 DailyContent가 이들의 생명주기를 관리한다.


3.2 orphanRemoval = true


  DailyContent에서 제거된 NewsItem/Quiz는 DB에서도 자동 삭제된다.
  즉, “부모(DailyContent)와의 연결이 끊긴 자식(NewsItem/Quiz)은 자동으로 DB에서 DELETE 하겠다” 라는 옵션이다.
    
      컬렉션에서 분리된 자식 엔티티를 그냥 메모리에서만 떼어내는 게 아니라, DB에서도 같이 지워주는 옵션
    
  
  관리 UI에서 DailyContent의 뉴스 한 개를 제거하면, JPA가 해당 NewsItem을 고아 객체로 판단하여 DB에서 DELETE까지 자동으로 해준다.


3.3 단방향 OneToMany + FK


  @JoinColumn(name = "daily_content_id") 를 통해 자식 테이블에 FK를 두되,
  자식 엔티티(NewsItem, Quiz) 쪽에는 @ManyToOne 필드가 없다.
  즉, 도메인 모델 상으로는 “DailyContent → 자식들” 단방향만 존재한다.


이는 “부모(하루치 경험)를 중심으로만 모델을 다루겠다”는 의도에 가깝다.

조회 최적화가 필요해지면, 별도의 조회용 쿼리/리포지토리를 두는 방식으로 보완할 수 있다.



4. 생성과 팩토리: 생성 시점에 불변식 잠그기

private DailyContent(
    CategoryId categoryId,
    DaySequence daySequence,
    Keyword keyword,
    ContentDescription description,
    ImageFile imageFile
) {
		this.categoryId = Objects.requireNonNull(categoryId, "categoryId는 null일 수 없습니다.");
    this.daySequence = Objects.requireNonNull(daySequence, "daySequence는 null일 수 없습니다.");
    this.keyword = Objects.requireNonNull(keyword, "keyword는 null일 수 없습니다.");
    this.description = Objects.requireNonNull(description, "description은 null일 수 없습니다.");
    this.imageFile = Objects.requireNonNull(imageFile, "imageFile는 null일 수 없습니다.");
}

public static DailyContent create(
    CategoryId categoryId,
    DaySequence daySequence,
    Keyword keyword,
    ContentDescription description,
    ImageFile imageFile
) {
    return new DailyContent(categoryId, daySequence, keyword, description, imageFile);
}



설계 포인트


  생성자는 private, 생성 경로는 create(...) 로만
    
      JPA용 기본 생성자 외에,
    
  


애플리케이션 코드에서 사용할 생성 경로를 정적 팩토리 하나로 통일했다.


  생성 시 검증 로직이 늘어나도 팩토리 내부만 수정하면 되고, 호출부는 그대로 유지된다.
    
      루트에서 하는 검증 vs VO에서 하는 검증
    
  
  루트는 “필수 구성요소가 null이 아닌가?”를 체크한다.
  VO는 “값 자체가 유효한가?(양수인지, 길이 제한 안쪽인지 등)”를 체크한다.
  이 레이어 분리를 통해, 생성 시점의 책임을 명확하게 나눌 수 있다.


서비스 계층에서의 사용 예

@Service
@RequiredArgsConstructor
public class DailyContentService {

    private final DailyContentRepository dailyContentRepository;

    @Transactional
    public DailyContent createDailyContent(CreateDailyContentCommand cmd) {
        DailyContent dailyContent = DailyContent.create(
            CategoryId.of(cmd.categoryId()),
            new DaySequence(cmd.daySequence()),
            Keyword.of(cmd.keyword()),
            ContentDescription.of(cmd.title(), cmd.summary(), cmd.body()),
            ImageFile.of(cmd.imageUrl())
        );

        return dailyContentRepository.save(dailyContent);
    }
}



서비스는 다음 역할만 가진다.


  원시 입력값 → VO 변환
  애그리거트 생성/저장 오케스트레이션


도메인 규칙(필수 값, 조합의 의미, VO 유효성)은 모두 루트와 VO 내부에 몰아둔 구조다.



5. 설명/키워드/이미지 변경: VO 교체 기반의 변경

public void updateDescription(ContentDescription newDescription) {
    Objects.requireNonNull(newDescription, "newDescription은 null일 수 없습니다.");
    this.description = newDescription;
}

public void changeSummary(String newSummary) {
    this.description = this.description.withSummary(newSummary);
}

public void changeTitle(String newTitle){
    this.description = this.description.withTitle(newTitle);
}

public void changeBodyText(String newBodyText) {
    this.description = this.description.withBodyText(newBodyText);
}

public void changeKeyword(Keyword newKeyword) {
    Objects.requireNonNull(newKeyword, "newKeyword는 null일 수 없다.");
    this.keyword = newKeyword;
}

public void changeImage(ImageFile newImageFile) {
    Objects.requireNonNull(newImageFile, "newImageFile는 null일 수 없다.");
    this.imageFile = newImageFile;
}



핵심 아이디어


  VO를 직접 수정하지 않고 새 VO로 교체한다.
    
      withSummary, withTitle 등은 새로운 ContentDescription 인스턴스를 만들어 반환한다.
      기존 VO는 불변 객체로 취급되며, 변경은 항상 “새 객체로 교체” 형태로 일어난다.
    
  
  루트는 “null 방지”까지만 책임
    
      null 방지는 DailyContent가,
      문자열 길이/형식 검증 등은 VO가 맡는다.
      단, String의 null/공백/길이 규칙은 ContentDescription 안에서만 관리한다.
    
  


서비스 계층에서의 사용 예는 다음과 같이 단순하다.

@Transactional
public void updateDailyContentSummary(Long dailyContentId, String newSummary) {
    DailyContent dc = dailyContentRepository.findById(dailyContentId)
        .orElseThrow(() -&gt; new NotFoundException("DailyContent not found"));

    dc.changeSummary(newSummary);
}





6. 컬렉션 보호와 도메인 메서드 기반 조작

6.1. 읽기 전용 뷰 제공

public List&lt;NewsItem&gt; getNewsItems(){
    return List.copyOf(newsItems);
}

public List&lt;Quiz&gt; getQuizzes(){
    return List.copyOf(quizzes);
}




  List.copyOf(...) 를 사용해 방어적 복사 + 불변 리스트를 반환한다.
  외부 코드에서 getNewsItems().add(...) 같은 조작을 시도하면 UnsupportedOperationException 이 발생한다.
  즉, 구조 변경은 반드시 애그리거트 루트의 메서드를 거치도록 강제한 것이다.


6.2. 추가/삭제는 루트 메서드를 통해서만

뉴스 추가:

public NewsItem addNewsItem(
    String title,
    NewsItemOrder order,
    WebLink link,
    ImageFile imageFile
) {
    Objects.requireNonNull(title, "title은 null일 수 없다.");
    Objects.requireNonNull(order, "order는 null일 수 없다.");
    Objects.requireNonNull(imageFile, "imageFile은 null일 수 없다.");
    Objects.requireNonNull(link, "link는 null일 수 없다.");

    validateNewsOrderDuplicate(order);

    NewsItem item = NewsItem.create(title, link, order, imageFile);
    newsItems.add(item);
    return item;
}



퀴즈 추가:

public Quiz addQuiz(
    String question,
    QuestionOrder order,
    QuizOptions options,
    AnswerIndex answerIndex
) {
    Objects.requireNonNull(question, "question은 null일 수 없다.");
    Objects.requireNonNull(order, "order는 null일 수 없다.");
    Objects.requireNonNull(options, "options는 null일 수 없다.");
    Objects.requireNonNull(answerIndex, "answerIndex는 null일 수 없다.");

    validateQuizOrderDuplicate(order);

    Quiz quiz = Quiz.create(question, order, options, answerIndex);
    quizzes.add(quiz);
    return quiz;
}



중복 순번 검증:

private void validateNewsOrderDuplicate(NewsItemOrder order) {
    if (newsItems.stream().anyMatch(n -&gt; n.getNewsItemOrder().equals(order))) {
        throw new IllegalArgumentException("동일한 뉴스 순번이 이미 존재합니다: " + order.value());
    }
}

private void validateQuizOrderDuplicate(QuestionOrder order) {
    if (quizzes.stream().anyMatch(q -&gt; q.getQuestionOrder().equals(order))) {
        throw new IllegalArgumentException("동일한 퀴즈 순번이 이미 존재합니다: " + order.value());
    }
}



설계 의도는 명확하다.


  “뉴스/퀴즈 추가”는 반드시 루트의 도메인 메서드를 통과해야 한다.
  그 안에서
    
      필수 값 null 방지
      순번(order) 중복 방지
      
        내부 엔티티 생성 규칙

        를 모두 처리한다.
      
    
  


서비스에서는 다음과 같이 사용하게 된다.

@Transactional
public void addNewsToDailyContent(Long dailyContentId, AddNewsCommand cmd) {
    DailyContent dc = dailyContentRepository.findById(dailyContentId)
        .orElseThrow(() -&gt; new NotFoundException("DailyContent not found"));

    dc.addNewsItem(
        cmd.title(),
        new NewsItemOrder(cmd.order()),
        WebLink.of(cmd.url()),
        ImageFile.of(cmd.imageUrl())
    );
}



외부에서 newsItems.add(...) 를 직접 호출할 수 없기 때문에,

애그리거트 불변식을 우회해서 깨뜨리기 어렵다.



7. 서비스 계층에서 본 “하루치 경험” 생성 흐름

DailyContent를 기준으로 “하루치 학습 경험 + 뉴스 + 퀴즈” 를 한 번에 생성하는 흐름을 예로 들면 다음과 같다.

@Transactional
public Long createWithNewsAndQuiz(CreateDailyContentAllInOneCommand cmd) {

    DailyContent dc = DailyContent.create(
        CategoryId.of(cmd.categoryId()),
        new DaySequence(cmd.daySequence()),
        Keyword.of(cmd.keyword()),
        ContentDescription.of(cmd.title(), cmd.summary(), cmd.body()),
        ImageFile.of(cmd.imageUrl())
    );

    for (CreateNewsCommand n : cmd.newsList()) {
        dc.addNewsItem(
            n.title(),
            new NewsItemOrder(n.order()),
            WebLink.of(n.url()),
            ImageFile.of(n.imageUrl())
        );
    }

    for (CreateQuizCommand q : cmd.quizList()) {
        QuizOptions options = QuizOptions.ofTexts(q.options());
        AnswerIndex answerIndex = new AnswerIndex(q.answerIndex());

        dc.addQuiz(
            q.question(),
            new QuestionOrder(q.order()),
            options,
            answerIndex
        );
    }

    DailyContent saved = dailyContentRepository.save(dc);
    return saved.getId();
}



관심사의 분리는 이렇게 정리할 수 있다.


  서비스 계층
    
      트랜잭션 관리
      유스케이스 오케스트레이션(“하루치 경험 + 뉴스 + 퀴즈를 한 번에 구성”)
    
  
  애그리거트 루트(DailyContent)
    
      하루치 경험의 일관성, 불변식, 내부 엔티티 관리
    
  
  VO
    
      자기 값의 유효성 검증
    
  
  
    Part 2에서는 DailyContent.java 한 파일을 기준으로,

    “하루치 학습 경험” 애그리거트가 어떤 책임을 갖고 있는지 살펴봤다.
  
  
    @Entity/@Table/유니크 제약으로

    “카테고리별 N일차는 하나”라는 불변식을 DB까지 끌어내리고,
  
  
    CategoryId, DaySequence, ContentDescription, Keyword, ImageFile 같은 값 객체들로

    원시 타입 대신 “의미 있는 타입 + 자체 검증”을 사용했다.
  
  
    NewsItem/Quiz는 같은 애그리거트 안에 속한 엔티티로 두고,

    cascade + orphanRemoval + 단방향 OneToMany 로 DailyContent 생명주기에 종속시켰다.
  
  
    생성/수정/추가/삭제는 전부 DailyContent의 도메인 메서드를 통해 이루어지며,

    서비스 계층은 “VO 변환 + 애그리거트 조합 + 트랜잭션”에만 집중한다.
  


                        </a>
                        <div class="info-post">
                                <a href="/Architecture" class="category">Architecture</a>
                            
                                <span class="date">· 2025-12-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Architecture/Domain%20Design/oneco-ddd-dailycontent-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/oneco-ddd-dailycontent.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Architecture/Domain%20Design/oneco-ddd-dailycontent-1.html"><h1 class="title_post">[ONECO DDD 도메인 설계 시리즈 Part 1] DailyContent 애그리거트 설계 스토리</h1></a>
                        <a href="/Architecture/Domain%20Design/oneco-ddd-dailycontent-1.html" class="txt_post">
                            [ONECO DDD 도메인 설계 시리즈 Part 1] DailyContent 설계 스토리


  “사용자가 카테고리를 선택하면, 매일 ‘키워드 + 설명 + 관련 뉴스들 + 퀴즈’를 한 세트로 공부한다.



소프트웨어 개발을 시작할 때 습관적으로 데이터베이스 스키마부터 그린다.

우리 프로젝트에서 요구를 듣고, 나와 팀원은 단순히 여러 테이블의 조합이 아니라 애그리거트들의 조합으로 시스템을 설계하기로 했다.

우리 프로젝트의 애그리거트 중 하나인 DailyContent 애그리거트의 설계 과정을 기록한다.

이 글은 “코드 설명”이 아니라 도메인 설계 의도를 기록하는 글이다. (코드 설명은 다음 글부터)


  왜 이 프로젝트에 DDD(도메인 주도 설계) 를 썼는지
  왜 DailyContent를 애그리거트 루트로 잡았는지
  왜 News / Quiz는 엔티티, 나머지는 값 객체(VO) 로 두었는지




1. 이 프로젝트에 DDD를 쓰기로 한 이유

프로젝트에서 사용자에게 제공되는 ‘하루치 공부’는 단순히 텍스트 본문 하나가 아니다.
“오늘의 경제 용어(키워드) + 설명 본문 + 관련 뉴스 기사들 + 복습 퀴즈”가 하나의 세트로 묶여서 제공된다.

처음에는 이걸 전형적인 관계형 DB 관점으로만 바라봤다.


  daily_content 테이블
  news 테이블
  quiz 테이블


그리고 서비스 레이어에서 이 세 테이블을 각각 조회해서 조립하는 방식으로 구현하려고 했다.

그런데 곧 여러 도메인 규칙들이 눈에 들어오기 시작했다.


  뉴스가 없는 콘텐츠는 발행될 수 없다.
  퀴즈의 순서는 콘텐츠 내에서 유일해야 한다.
  콘텐츠가 삭제되면, 그날의 뉴스나 퀴즈만 덩그러니 남아서는 안 된다.
  …


이 규칙들을 서비스 레이어의 수많은 if 문으로만 관리하다 보면

서비스 레이어는 점점 “조립 + 검증 + 예외처리”가 뒤섞인 거대한 절차 코드가 될 것이 뻔했다.

그래서 “서비스에서 데이터 조합을 관리하는 구조” 대신,

도메인 객체 스스로가 자신의 상태를 검증하고, 규칙을 보장하는 구조로 바꾸기로 했다.

즉, daily_content, news, quiz를 느슨하게 조립하는 것이 아니라

“하루치 공부”라는 개념 자체를 하나의 애그리거트(DailyContent)로 묶고,

그 안에서 “뉴스가 최소 1개 이상인지, 퀴즈 순번이 중복되지 않는지” 같은 규칙을 책임지도록 설계했다.



2. DailyContent 애그리거트의 큰 그림

먼저 도메인 구조를 그림으로 보면 이렇게 생겼다.



이 구조를 한 줄로 설명하면:


  DailyContent(AR)가 “카테고리별 N일차”를 대표하고,

  그 아래에 NewsItem/Quiz 엔티티와 여러 값 객체들이 매달려 있는 형태.



이다.



3. 왜 DailyContent가 애그리거트 루트인가?

3.1. 도메인 상의 한 덩어리: 하루치 학습 경험

기획/운영 관점에서 보면, 이 서비스의 세계는 이렇게 보인다.


  카테고리 “돈의 흐름”은 14일짜리 코스
  그중 “3일차”에는
    
      오늘의 키워드 1개
      설명(제목, 요약, 본문)
      관련 뉴스 2~3개
      퀴즈 1~3개
    
  
  운영자가 하는 일:
    
      “돈의 흐름 3일차 콘텐츠 작성/수정/배포”
      잘못 올라갔으면 “3일차 전체 롤백”
    
  


즉, 비즈니스가 바라보는 일관성의 최소 단위는


  “카테고리 X의 N일차”



이다.

데이터베이스 입장에서는 여러 테이블이지만, 사람 입장에서는 이것이 하나의 세트다.

그래서 이 세트를 대표하는 루트로 DailyContent 를 세웠다.


  트랜잭션 단위: “3일차 DailyContent + 그 하위의 News/Quiz 포함” 한 번에 저장
  API 단위: /api/daily-contents/{categoryId}/{daySequence} 로 한 번에 조회/제공할 수도 있음


DDD에서 말하는 “애그리거트”의 정의를 가져오면:


  “항상 함께 일관성을 유지해야 하는 도메인 객체들의 묶음”



이 프로젝트에서는 그게 바로 DailyContent와 그 내부 구성 요소들이었다.

3.2. 유일성 규칙과 경계

DailyContent에는 이런 규칙이 있다.


  같은 카테고리에서 같은 DaySequence는 하나만 존재해야 한다.


이 규칙을 코드/DB에선 이렇게 녹였다.


  도메인 규칙: “CategoryId + DaySequence 조합은 유일”
  DB 제약: unique(category_id, day_sequence)


이 조합 자체가 바로 “애그리거트 식별자”에 해당한다.

즉,


  “이 DailyContent가 누구인가?” → CategoryId + DaySequence로 설명 가능
  “이 세트를 하나로 보고 관리한다” → 애그리거트 루트로서 DailyContent가 적합




4. 왜 NewsItem / Quiz는 루트가 아니라 엔티티인가?

4.1. 독립성 vs 종속성

NewsItem과 Quiz는 둘 다 엔티티다.

ID도 있고, 각각 수정/삭제가 가능하다. 그런데도 애그리거트 루트로 올리지 않았다.

이유는 단순하다.


  NewsItem/Quiz는 DailyContent 없이는 비즈니스적으로 의미가 거의 없다.
    
      “돈의 흐름 3일차 2번 뉴스”라는 문맥이 있어야만 의미가 생김
      “혼자 떠다니는 뉴스 엔티티”를 외부에 직접 노출할 필요가 없다
    
  
  라이프사이클도 DailyContent에 종속된다.
    
      3일차를 삭제하면 그 아래 뉴스/퀴즈도 같이 사라지는 것이 자연스럽다.
      “퀴즈만 남아있는 3일차 없는 데이터” 같은 상태는 원하지 않는다.
    
  


그래서 NewsItem / Quiz는:


  개별적으로 식별 가능한 엔티티이긴 하지만
  트랜잭션/일관성/수명 관점에서는 DailyContent 내부의 구성 요소


로 보는 것이 더 자연스러웠다.

4.2. 만약 News/Quiz를 각각 애그리거트 루트로 만들었다면?

반대로 설계했다면 이런 형태가 된다.


  NewsItem 이 독립 애그리거트 → /news/{id} 로 직접 관리
  Quiz 가 독립 애그리거트 → “퀴즈 관리 시스템”처럼 동작


그럼 이런 문제가 바로 튀어나온다.


  “3일차 전체 롤백”이 어려워진다.
    
      DailyContent, 관련 NewsItem, Quiz를 서로 다른 애그리거트로 나눠버리면
      롤백/수정 시에 여러 애그리거트를 동시에 건드리는 복잡한 트랜잭션이 필요
    
  
  “3일차를 추가한다” 같은 간단한 요구도
    
      DailyContent 생성
      관련 NewsItem 애그리거트 여러 개 생성
      관련 Quiz 애그리거트 여러 개 생성
      
        이들을 서로 참조 연결

        같이 분산된 작업이 된다.
      
    
  


그래서 초반 설계 단계에서:


  “3일차 전체”가 하나의 트랜잭션 단위
  그 아래 News/Quiz는 그냥 종속 엔티티


로 두는 것이 맞다고 판단했다.



5. 왜 나머지는 값 객체(VO)로 만들었는가?

DailyContent 애그리거트 안에는 많은 VO가 있다.


  CategoryId
  DaySequence
  Keyword
  ContentDescription
  ImageFile
  WebLink
  NewsItemOrder, QuestionOrder
  AnswerIndex, QuizOptions, QuizOption …


이걸 그냥 다 String, Long, int 로 두고 진행할 수도 있었지만, 의도적으로 값 객체로 빼냈다.

5.1. “의미 있는 타입”으로 만들기

예를 들어 CategoryId를 Long 대신 VO로 만든 이유는:


  Long 타입만 보면 “이 숫자가 뭔데?”가 전혀 안 보인다.
  실수로 memberId를 넣어도 컴파일이 된다.
  null, 0, 음수 같은 값도 아무렇지 않게 들어간다.


CategoryId VO로 만들면:


  타입 이름만 봐도 “카테고리 식별자”라는 의미가 코드에 드러난다.
  생성자에서 “양수만 허용” 같은 비즈니스 규칙을 강제할 수 있다.
  잘못된 타입이 섞이는 것을 컴파일 단계에서 막을 수 있다.


DDD의 좋은 값 객체는:


  “이것이 무엇을 뜻하는지” 를 타입 이름에 담고
  “어떤 값이 허용/금지되는지” 를 생성 시점에 검증한다.


5.2. 검증 로직을 도메인 내부로 밀어넣기

Keyword, ContentDescription, WebLink, ImageFile, AnswerIndex, QuizOptions 등은

모두 “검증을 어디에 둘 것인가?”라는 문제와 직결되어 있다.


  Controller/Service마다 if (title.length() &gt; 200) 같은 코드를 반복할 수도 있지만,
  그러면 중복 + 누락 + 일관성 깨짐의 가능성이 커진다.


대신 VO에 넣으면:


  한 곳에서만 규칙을 정의하면 된다.
  규칙이 바뀌면 그 값 타입만 바꾸면 된다.
  엔티티는 “유효성이 보장된 값 타입들만 조합”하도록 만들 수 있다.


즉, 엔티티는 조립, VO는 검증이라는 역할 분리가 생긴다.



6. 정리: 이 설계가 말하고 싶은 것

이 글에서 하고 싶은 말은 사실 딱 하나다.


  “우리는 DB 테이블을 설계한 게 아니라,

  ‘하루치 학습 경험’이라는 도메인 개념을 코드로 옮겼다.”



그래서


  DailyContent를 애그리거트 루트로 잡았고
  News/Quiz를 그 아래 엔티티로 두었고
  나머지는 값 객체로 잘게 쪼개서 의미와 규칙을 타입에 담았다.


다음 글들에서는 이 안에서:


  코드를 통해서 애그리거트 분석하기
  AbstractSequence를 써서 DaySequence / QuestionOrder / NewsItemOrder를 어떻게 통합했는지
  QuizOptions를 JSON으로 매핑하면서도 도메인 모델을 “JSON 냄새”로부터 어떻게 지켜냈는지


같은 조금 더 디테일한 주제들을 풀어볼 수 있다.

                        </a>
                        <div class="info-post">
                                <a href="/Architecture" class="category">Architecture</a>
                            
                                <span class="date">· 2025-12-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Architecture/security-auth/2025-11-30-kakao-login.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/2025-11-30-kakao-login.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Architecture/security-auth/2025-11-30-kakao-login.html"><h1 class="title_post">카카오 OAuth 로그인 흐름 이해하기: JS SDK + Authorization Code 플로우</h1></a>
                        <a href="/Architecture/security-auth/2025-11-30-kakao-login.html" class="txt_post">
                            카카오 로그인 동작과정 분석하기(sdk 방식)

[전제 조건 및 설계 원칙]


  환경 전제
    
      웹 브라우저 기준으로 설명한다.
      
        모바일 앱이라면 authorize() 호출 시 카카오톡 앱이 먼저 실행되고,

        그 안의 WebView에서 kauth.kakao.com 페이지를 띄워 로그인/동의가 진행된다.
      
    
  
  로그인 시작 방식
    
      
        로그인 버튼 클릭 시, 프론트에서 백엔드를 거치지 않고 바로

        Kakao.Auth.authorize() 를 호출한다.
      
      
        이 호출은 브라우저를 https://kauth.kakao.com/oauth/authorize 로 이동시킨다.

        → 프론트 → (백엔드 패스) → Kakao Auth Server
      
    
  
  인가 코드 수신 주체
    
      redirect_uri 를 프론트 주소로 설정한다.
      
        동의 완료 후, Kakao Auth Server는

        302 Location: {redirect_uri}?code=... 로 응답한다.
      
      브라우저가 이 redirect_uri(프론트 URL)로 이동하면서 인가 코드는 먼저 프론트가 받는다.
      프론트는 URL에서 code를 추출해 백엔드 로그인 API로 전달하여 토큰 발급·회원 처리 등을 진행한다.
    
  


전체 아키텍처



1. 사용자가 로그인 버튼 클릭: 프론트 → Kakao Auth 서버

사용자가 우리 사이트에서 “카카오로 로그인” 버튼을 누른다.

JS SDK 방식에서는 이 버튼 클릭이 결국 카카오 JS SDK의 authorize 호출로 이어지고,

이 함수는 브라우저의 주소를 카카오 Auth 서버의 인가 엔드포인트로 바꾸어 버린다.

Kakao.Auth.authorize({
	redirectUri: 'http://localhost:5173/oauth/kakao/callback'
});


결국 이 호출은 다음과 같이 나가게 된다.

https://kauth.kakao.com/oauth/authorize?
	client_id=
	&amp;redirect_uri=http://localhost:5173/oauth/kakao/callback
	&amp;response_type=code 


여기서 중요한 점은:


  이 시점에는 우리 백엔드를 전혀 거치지 않는다는 것.
  브라우저는 곧바로 kauth.kakao.com으로 이동해서 카카오 Auth 서버와 통신한다는 것.


로그인 시작부터 브라우저 ↔ 카카오 Auth 서버가 직접 붙는 구조다.

1-1. 로그인 안 되어 있을 때 : Auth → Account → Auth 왕복



카카오 Auth 서버 입장에서, 브라우저가 보낸 인가 코드 요청을 받았다.


  Auth 서버는 이 브라우저에 카카오 계정 로그인 세션이 있는지 확인한다.
  로그인 세션이 없다면, “먼저 카카오 계정 로그인을 시켜야 한다”고 판단한다.
  
    그래서 Auth 서버는 브라우저에게 “카카오 Account 서버로 가라”는 의미의 302 리다이렉트 응답을 보낸다.

    이때 응답의 Location 헤더에는 Account 서버의 로그인 URL과 함께 continue라는 파라미터가 붙어 있다.
  



  continue 파라미터



  로그인까지 끝난 뒤 다시 돌아와야 할 Auth 서버의 /oauth/authorize 요청 전체를 그대로 기억해 두는 것



https://accounts.kakao.com/login?
continue=https%3A%2F%2Fkauth.kakao.com%2Foauth%2Fauthorize%3Fclient_id%3Dd2ffdfaa297012904086e71f5d7eda1f%26redirect_uri%3Dhttp%253A%252F%252Flocalhost%253A3000%252Foauth%252Fkakao%252Fcallback%26response_type%3Dcode%26through_account%3Dtrue%26auth_tran_id%3DwbrMy9IcVMYhPjgkbCpf7-TiGF7balKdB--tpTWfCg0VmwAAAZrDiMg9#login


continue= 뒤에 있는 건 전부 URL 인코딩된 문자열이다.


  
    URL 디코더를 통해서 위의 인코딩된 문자열 디코딩 결과

      https://accounts.kakao.com/login?
  continue=https://kauth.kakao.com/oauth/authorize?
  client_id={client_id}&amp;
  redirect_uri=http://localhost:5173/oauth/kakao/callback&amp;
  response_type=code&amp;
  through_account=true&amp;
  auth_tran_id=wbrMy9IcVMYhPjgkbCpf7-TiGF7balKdB--tpTWfCg0VmwAAAZrDiMg9#login
    

    
      continue=
    

    → 우리가 원래 쳤던 인가 코드 받는 엔드포인트

    
      client_id=…
    

    →  JS SDK 플로우에서는 JavaScript 키가 client_id로 사용된다.

    
      redirect_uri
    

    → 동의 후 인가 코드를 보내줄 프론트 주소(백으로 설정하면 백주소)

    
      response_type = code
    

    → OAuth2에서 인가 코드 플로우를 쓰겠다는 뜻

    
      through_account = true
    

    → 계정 로그인 서버를 통해서 처리하는 중이다 정도의 카카오 내부 플래그

    
      auth_tran_id=
    

    → 카카오가 이 인증 트랜잭션을 추적하기 위한 내부 트랜잭션 ID
  


브라우저는 Auth 서버가 보내준 Location 값을 그대로 따라가서 Account 서버의 로그인 페이지를 연다.



이제 사용자는 이 페이지에서 카카오 계정 이메일과 비밀번호를 입력하고 로그인 버튼을 누른다.

로그인이 성공하면 Account 서버는 continue에 들어 있던 인가 요청 URL을 꺼내서,

다시 그 URL로 302 리다이렉트를 보낸다.

브라우저는 또 한 번 302 Location을 따라가서 다시 Auth 서버의 /oauth/authorize 로 돌아간다.

로그인 버튼 누른 뒤에 일어나는 일


  사용자는 여기서 아이디 비밀번호를 누르고 로그인 버튼을 누른다.
  
    로그인 버튼을 누르면 이 폼을 Account 서버로 제출한다.

    → 예: POST https://accounts.kakao.com/login 같은 요청
  
  
    Account 서버가 ID/비번 검증해서 로그인 성공 처리하고 내부에서 continue 파라미터에 있던 값을 꺼내서 응답으로 돌려준다.

     HTTP/1.1 302 Found
 Location: https://kauth.kakao.com/oauth/authorize?client_id=...&amp;redirect_uri=...&amp;response_type=code&amp;...
    
  
  
    브라우저는 이 Location 헤더를 보고

    → 자동으로 
  GET https://kauth.kakao.com/oauth/authorize?... 요청을 다시 보냄

     https://kauth.kakao.com/oauth/authorize?
 client_id={client_id}&amp;
 redirect_uri=http://localhost:5173/oauth/kakao/callback&amp;
 response_type=code
    
  


브라우저가 302 응답을 받자마자 순식간에 다음 주소로 이동하기 때문에 육안으로는 볼 수 없다.


  확인 방법
    
      F12를 눌러 개발자 도구를 연다.
      상단 탭 중 Network 탭을 클릭한다.
      Network 탭 상단 메뉴바에 있는 Preserve log (로그 보존) 체크박스를 반드시 체크한다.
        
          이걸 체크하지 않으면, 페이지가 accounts에서 kauth로 이동(리다이렉트)하는 순간 이전 기록이 전부 지워져서 302 응답을 볼 수 없다.
        
      
      이제 브라우저에서 로그인 버튼을 눌러 로그인을 시도한다.
      Network 탭의 리스트 중에서 login 혹은 authorize 라는 이름의 요청을 찾는다.
      Status(상태) 코드가 302 인 항목을 클릭한다.
      오른쪽 상세 창의 Response Headers(응답 헤더) 탭을 보면 Location 항목에 네가 찾던 그 URL(https://kauth.kakao.com/...)이 적혀 있는 것을 확인할 수 있다.
    
  


2. 동의 화면: Auth 서버가 HTML을 내려주고, 브라우저가 렌더링한다.

현재 상태


  브라우저는 카카오 계정에 로그인된 상태다.
  Auth 서버는 인가 코드 요청을 정상적으로 받을 수 있는 상태다.


Auth 서버는 이 요청에 대해 다음과 같이 행동한다.


  
    사용자가 이 앱(우리 서비스)에 처음 접근했다면

    → 어떤 정보(프로필, 이메일 등)를 제공할지 보여주는 동의 화면을 내려준다.
  
  
    이미 예전에 한 번 동의한 앱이라면

    → 동의 화면을 생략하고 바로 인가 코드 발급으로 넘어갈 수 있다.
  


여기서 중요한 점:


  동의 화면은 항상 웹 페이지다.
  서버는 Auth 서버(kauth)에서 HTML을 내려주고,
  클라이언트가 브라우저라면 브라우저가,
카카오톡 앱이라면 카카오톡 앱 안의 WebView가 그 HTML을 렌더링할 뿐이다.


웹 기준에서는 그냥 브라우저에서 카카오 동의 화면 페이지를 보는 것이라고 이해하면 된다.



3. 동의하고 계속하기

사용자가 동의 화면에서 “동의하고 계속하기” 버튼을 누른다.


  브라우저는 이 버튼을 누르면서 Auth 서버로 폼 제출/JS 요청을 보내고,
  Auth 서버는 내부적으로 인가 코드(code)를 하나 발급한 뒤,
  아래와 같이 응답한다.


HTTP/1.1 302 Found
Location: {redirect_uri}?code=AUTH_CODE&amp;state=STATE_VALUE



중요한 점:


  redirect_uri는 우리가 처음 /oauth/authorize 요청에 넘겨줬던 값이다.
  
    Auth 서버는 이 값을 그대로 끌고 와서 뒤에 ?code=...&amp;state=... 를 붙인 뒤

    Location 헤더에 넣는다.
  
  브라우저는 “redirect_uri”라는 개념을 모른다.
    
      302의 Location에 해당하는 URL로 이동할 뿐이다.
    
  




4. redirect_uri가 프론트 일 때

우리는 전제로 redirect_uri를 프론트 주소로 놓았다.

redirect_uri = http://localhost:5173/oauth/kakao/callback


그럼 Auth 서버의 응답은 대략 이렇게 된다.

HTTP/1.1 302 Found
Location: http://localhost:5173/oauth/kakao/callback?code=AUTH_CODE&amp;state=...


브라우저는 이걸 보고:

GET http://localhost:5173/oauth/kakao/callback?code=AUTH_CODE&amp;state=...


를 다시 호출한다.

이 시점에 일어나는 일:


  이 URL에 매핑된 프론트 라우트(React/Vite) 가 로드된다.


이렇게 하면 인가 코드는 백엔드가 직접 받는 것이 아니라, 브라우저(프론트)가 URL로 전달받고 → 백엔드로 다시 넘기는 구조가 된다.



5. 백엔드: 인가 코드 → 액세스 토큰 교환



프론트에서 /api/auth/kakao/login 으로 code를 넘기면,

이제부터는 백엔드(Spring) 의 역할이다.


  
    카카오 Auth 서버의 /oauth/token 엔드포인트를 호출한다.

     POST https://kauth.kakao.com/oauth/token
 Content-Type: application/x-www-form-urlencoded
    
 grant_type=authorization_code
 &amp;client_id=REST_API_KEY
 &amp;redirect_uri=http://localhost:5173/oauth/kakao/callback
 &amp;code=AUTH_CODE
    
    

    여기서 중요한 점:

    
      이때 client_id로 사용하는 것은 REST API 키다.
      프론트(Javascript SDK)에서는 JavaScript 키를 사용한다.
      REST API 키는 백엔드에서만 사용해야 하는 비공개 키다.
    
  
  
    응답으로 액세스 토큰/리프레시 토큰을 받는다.
  


{
"token_type": "bearer",
"access_token": "ACCESS_TOKEN",
"expires_in": 21599,
"refresh_token": "REFRESH_TOKEN",
"refresh_token_expires_in": 5183999,
"scope": "profile_nickname account_email"
}




6. 백엔드: Kakao API Server에서 유저 정보 조회



이제 백엔드는 받은 access_token을 이용해

Kakao API Server (kapi.kakao.com) 에서 유저 정보를 조회한다.

GET https://kapi.kakao.com/v2/user/me
Authorization: Bearer ACCESS_TOKEN
Content-Type: application/x-www-form-urlencoded;charset=utf-8



응답 예시는 대략 이런 형태다.

{
  "id": 1234567890,
  "kakao_account": {
    "profile": {
      "nickname": "홍길동",
      "profile_image_url": "..."
    },
    "email": "example@kakao.com",
    "has_email": true,
    "is_email_valid": true,
    "is_email_verified": true}
}



이 정보를 기반으로 우리 도메인에서:


  SocialAccount 엔티티 (provider=KAKAO, social_user_id=카카오 id) 생성/조회
  Member 엔티티와 1:N 관계로 묶기
  이메일/전화번호로 기존 회원과 연결 여부 판단
  신규 가입이면 Member 생성, 기존 회원이면 해당 Member에 소셜 계정 추가


같은 작업을 수행하면 된다.



7. 우리 서비스 토큰 발급 및 최종응답



마지막으로, 우리 서비스 자체의 로그인 처리를 한다.


  Member / SocialAccount 기준으로 실제 사용자 식별
  우리 서비스용 JWT Access Token / Refresh Token 발급
  프론트로 응답


예:

{
  "accessToken": "OUR_SERVICE_ACCESS_TOKEN",
  "refreshToken": "OUR_SERVICE_REFRESH_TOKEN",
  "member": {
    "id": 100,
    "nickname": "김기민",
    "role": "PARENT"
  }
}



이제 사용자는 “카카오 계정으로 로그인한 우리 서비스 사용자”가 된다.



                        </a>
                        <div class="info-post">
                                <a href="/Architecture" class="category">Architecture</a>
                            
                                <span class="date">· 2025-11-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Architecture/System%20Design/at-least-once-notification-redis-queue-blmove-idempotency.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/at-least-once-notification-redis-queue-blmove-idempotency.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Architecture/System%20Design/at-least-once-notification-redis-queue-blmove-idempotency.html"><h1 class="title_post">[시스템 설계] 하루 한 번 알림을 “누락 없이” 보내기 위한 Redis 큐 &amp; 워커 설계</h1></a>
                        <a href="/Architecture/System%20Design/at-least-once-notification-redis-queue-blmove-idempotency.html" class="txt_post">
                            [시스템 설계] 하루 한 번 알림을 “누락 없이” 보내기 위한 Redis 큐 &amp; 워커 설계

1. 시스템 목표


  “하루에 한 번”과 같이 정해진 알림을 누락 없이 전송한다. (At-least-once Delivery)
  API 서버 장애, DB 장애, 애플리케이션 장애 등 어떤 상황에서도 작업 유실을 방지한다.
  장애 복구 시 발생할 수 있는 중복 발송을 최소화하고, 제어(멱등성)할 수 있도록 설계한다.


2. 아키텍처 설계



[1단계: 생산자 (Scheduler) 영역]


  별도의 스케줄러 스레드가 알림 발송 시간 10분 전에 User 테이블에서 알람 설정 한 유저 정보를 조회한다.
  유저 정보를 조회한 스케줄러는 오늘 알림 설정을 on 한 사용자들에 대해서만 quiz_notification_log 테이블을 생성하고 저장한다. (초기 status=’PENDING’)
  발송 시간이 되면 메인 스케줄러 스레드는 quiz_notification_log 테이블에서 오늘 작업들을 조회한다.
  quiz_notification_log 테이블의 status를 ‘PENDING’에서 ‘QUEUED’로 변경한다.
    
      트랜잭션 처리 함으로써 전부 QUEUED로 변경되도록 한다.
    
  
  트랜잭션으로 상태 변경(‘QUEUED’)된 작업들을 레디스 큐(main-queue)에 푸시한다.
    
      푸시 중간에 서버가 다운되면 보조 스케줄러가 돌면서 status=’QUEUED’인데 10분이 지나도록 SENT로 바뀌지 않은 작업들을 찾아서 다시 큐에 푸시한다. (작업 유실 방지)
        
          updated_at/ created_at 기반으로 판단한다.
        
      
    
  


[2단계: 소비자 (Worker) 영역]


  main-queue에서 worker-N-processing-queue(워커 전용 백업 큐)로 BLMOVE를 통해 원자적 이동을 실행한다.
    
      processing-queue에서는 작업의 모든 과정이 완료되어야만 해당 작업을 삭제한다.
    
  
  워커 스레드가 자신의 processing-queue에서 작업을 가져온다.
    
      processing-queue에서 작업을 가져오는 것은 읽기(LRANGE 등)로 처리한다.
      삭제는 작업의 모든 과정이 완료된 후 마지막에 수행된다.
    
  
  quiz_notification_log 테이블의 status를 ‘QUEUED’에서 ‘PROCESSING’으로 변경한다.
    
      (의미: 작업이 큐에서 꺼내져 처리가 시작되었음을 보장. API 호출 성공 여부는 보장 X)
    
  
  사용자에게 알람을 보내는 API를 호출한다.
  API 응답 결과에 따라 작업을 분기 처리한다.
    
      성공 시: quiz_notification_log 테이블의 status를 ‘PROCESSING’에서 ‘SENT’로 변경한다. (→ 11단계로 이동)
      일시적 실패 시 (5xx 등): retry-queue로 (원자적 이동을 통해) 옮겨지며, retry 전문 워커 스레드에 의해서 재시도 된다.
      영구적 실패 시 (4xx 등): dlq-queue로 (원자적 이동을 통해) 옮겨진다. 개발자가 수동으로 원인 분석 및 버그 수정을 해야 한다.
    
  
  최종 처리 후 processing-queue에서 작업을 삭제한다.
    
      DB status가 ‘SENT’로 상태 변경된 것을 확인한 후, LREM으로 processing-queue에서 해당 작업을 제거한다.
    
  


3. 실패 지점

[생산자(Scheduler) 영역]


  DB 조회 실패
    
      문제: DB 장애로 유저 목록 조회가 실패한다.
      결과: 스케줄러가 아예 시작을 못 한다.
    
  
  큐 등록 실패
    
      문제: 큐 등록을 하다가 중간에 스케줄러가 다운된다.
    
  


[소비자(Worker) 영역]


  큐 작업 확보 문제
    
      문제: BRPOP을  썼을 때, 워커가 작업을 꺼내고 처리(API 호출)하기 직전에 다운된다.
      해결책: BLMOVE를 사용해 작업을 processing-queue로 안전하게 이동시킨다.
    
  
  API 호출 실패
    
      문제: 카카오 서버가 에러를 반환하거나 네트워크가 불안정하다.
      해결책: retry-queue 로 작업을 보내 재시도한다. (최종 실패 시 dlq-queue로 격리)
    
  


[워커가 API 성공 ‘이후’에 실패하는 영역]


  DB 로그 기록 실패
    
      문제: API 호출은 성공했는데 , quiz_notification_log 테이블에 SENT라고 UPDATE 하려는 순간 DB 장애 발생→ 퀴즈는 발송됐지만, DB엔 기록이 안 됐다.
    
  
  작업 완료 처리 실패
    
      문제: API 호출도 성공하고, DB 로그 기록도 성공했다. 이제 processing-queue 에서 작업을 LREM (삭제) 하려던 순간 Redis가 다운된다.
    
  




큐 등록 실패 문제 해결 방안

1. 사전에 발송 대상을 확정 (log 테이블 생성)

스케줄러가 정해진 발송 시간에 User 테이블을 읽는 것이 아니라, 그 이전에 ‘오늘 보낼 작업 목록’을 quiz_notification_log 테이블에 미리 생성해 둔다.


  테이블 : quiz_notification_log
  컬럼: id(PK), user_id(FK), quiz_data, status (PENDING, QUEUED, PROCESSING, SENT, FAILED)
  시간 : 퀴즈 발송 10분 전
  동작: 별도의 스케줄러가 User 테이블을 읽어, 오늘 퀴즈를 받아야 할 목록을 quiz_notification_log에 INSERT 한다. (초기 상태 ‘PENDING’)
  결과: quiz_notification_log 테이블에 오늘 처리해야 할 작업이 status = ‘PENDING’ 상태로 모두 저장된다.


2. 작업 등록 스케줄러

정해진 발송 시간이 되면 메인 스케줄러(Producer)가 동작한다.

이 스케줄러는 User 테이블을 보는 것이 아니라, quiz_notification_log 테이블만 본다.

(만약 사용자가 많으면 한 번에 처리하지 않고, 나눠서 배치로 처리한다)

3. 트랜잭션 관리 &amp; 실패 시 복구

A. DB 트랜잭션


  @Transactional이 시작된다.
  PENDING인 작업을 찾아서(배치면 배치 개수만큼), 다른 스케줄러가 접근하지 못하도록 DB 락을 건다.
    
      User 테이블이 아닌 quiz_notification_log 테이블 락이여서 락 경합이 발생하지 않는다.
    
  
  락을 건 작업들의 status를 QUEUED 로 변경한다.
  트랜잭션이 COMMIT 된다.
    
      만약 1~4번 사이에서 서버가 다운되면?
    
    
      DB 트랜잭션이 롤백된다.
      status는 다시 PENDING 상태로 돌아가고 락도 풀린다.
      Redis에는 아무것도 들어가지 않는다.
      결과: 스케줄러가 재시작되면 이 PENDING 작업 1000개를 다시 처리한다.
        
          @Scheduled(fixedRate = 60000) 으로 스레드 풀에 있는 태스크 스케줄러에게 작업을 할당한 후, while 문에서 PENDING 상태인 작업이 없을 때까지 루프를 돌게 한다.
          예를 들어 서버가 다운되더라도 서버가 재시작한다면 스케줄러가 다시 돌며 실패한 작업들을 PENDING 상태가 없을 때까지 작업을 처리한다.
        
      
    
  


B. Redis 등록 ( DB 커밋 이후)


  A번의 DB 트랜잭션이 성공적으로 COMMIT 되었다 (DB는 QUEUED 상태)
  이제 for 문을 돌며 Redis에 1000개의 작업을 LPUSH 한다.
    
      만약 LPUSH 중간에 서버가 다운되면?
    
    
      DB 상태: 1000개 모두 QUEUED 이다.
      Redis 상태: 600개만 큐에 들어갔다.
      문제: 400개는 QUEUED 상태로 DB에 저장된다(REDIS에는 없음)
      해결책: 보조 스케줄러가 2분마다 돌면서, quiz_notification_log에 status = 'QUEUED' 인데 10분이 지나도록 SENT 로 바뀌지 않은 작업들을 찾는다.
      나머지 400개의 작업을 다시 Redis 큐에 LPUSH 해준다.
      결과: 작업 유실이 복구된다. (최소 1회 보장)
    
  




큐 작업 확보 문제

1. 문제 상황

BRPOP(Blocking Right Pop)은 큐에서 데이터를 꺼내오는 순간 그 데이터는 큐에서 영구적으로 삭제된다.

그래서 워커가 Redis에서 작업을 꺼내와도 워커 서버가 다운되면 작업이 유실된다.

2. BLMOVE (원자적 이동 후 데이터 반환)

두 가지 일을 단 하나의 원자적(Atomic) 명령으로 묶어버린다.


  일 1: main-queue에서 데이터를 꺼낸다. (Pop)→ processing-queue에 데이터를 밀어 넣는다. (Push)
  일 2: 성공한 데이터를, 명령을 요청했던 워커에게 응답으로 즉시 반환한다.


즉 둘 다 성공하거나 둘 다 실패하는 것을 Redis 서버가 보장한다.

동작 순서


  워커
    
      BRPOP 대신 BLMOVE 명령을 실행한다.
      BLMOVE main-queue worker-1-processing-queue RIGHT LEFT 0
    
    
      설명: RIGHT에서 꺼내서(큐 뒤) LEFT로 넣기(큐 앞)
      0의 의미: main-queue에 작업이 들어올 때까지 영원히 대기한다.
      worker 스레드마다 개별 processing-queue를 둔다
      공용으로 두면 갇힌 작업을 누가 어떻게 복구할지 매우 복잡해진다. (A 워커가 특정 작업을 처리중인지 실패했는지 모르기 때문)
    
  
  Redis
    
      task-123을 main-queue에서 삭제함과 동시에 worker-1-processing-queue에 추가한다.(원자적)
      모든 이동이 완료된 후, 워커에게 task-123을 반환한다.
    
  
  워커
    
      task-123을 받고 이제 이 작업이 worker-1-processing-queue에 안전하게 백업된 것을 안다.
      이제 API 호출을 시작한다.
    
  
  워커
    
      성공 시
    
    
      
        API 호출 직전에, DB상태를 QUEUED에서 PROCESSING으로 먼저 변경(UPDATE)한다.

        (만약 이 UPDATE가 실패하면(DB장애, 애플리케이션 서버 다운 등), API 호출은 일어나지 않았고 큐에도 작업이 남아있으므로 재시작시 100% 안전하다.)
이 UPDATE가 성공한 작업에 대해서만 API 호출을 시작한다.
      
      API 호출이 성공하고, DB 로그(PROCESSING-&gt; SENT) 기록도 성공한다.
      모든 처리가 완료되었으므로, 백업 큐에 있던 작업을 수동으로 삭제해야 한다.
      LREM worker-1-processing-queue 1 task-123
      (의미: worker-1-processing-queue에서 task-123 값 1개를 찾아서 삭제)
    - 실패 시
      워커 애플리케이션 다운된 후 재시작한다.
      로직 1순위로 worker-1-processing-queue를 먼저 확인한다.
      worker-1-processing-queue에 아까 다운될 때 처리 중이던 task-123이 그대로 남아있는 것을 발견한다.
      이 task-123  작업을 다시 처리(API 호출)하기 시작한다.
    
  


주의사항


  
    다시 작업을 꺼낼때는 읽기로 꺼내기(삭제는 최종)

    만약 워커가 다운된 후 processing-queue에서 작업을 또다시 꺼내어 처리한다면 다시 워커가 다운된다면 데이터가 유실된다.

    → 따라서 실패 후 재처리 로직은 삭제가 아닌 읽기이다.

    재시작된 워커 동작 원리

    
      작업 확인
        
          processing-queue에서 작업을 삭제하지 않고 읽기만 한다.
          명령어: LRANGE worker-1-processing-queue 0 0
          (의미: worker-1-processing-queue의 첫 번째 작업을 삭제하지 말고, 보여줘)
        
        
          워커가 main-queue에서 작업을 확보할 때 단 1개의 작업만 processing-queue로 가져온다.
            
              워커 하나는 동시에 하나의 작업만 처리한다.
            
          
          api 호출 → DB 로그 변경 → 큐에서 데이터 삭제 이 과정이 끝나야 processing-queue에서 작업을 삭제한다.
        
      
      작업 재처리
        
          워커는 task-123이 큐에 안전하게 남아있는 상태여서, API 호출을 다시 시도한다.
        
      
      만약 또 실패하면?
        
          워커가 API 호출 중에 또 다운되어도, 1번 단계에서 작업을 삭제한 적이 없으므로 task-123은 processing-queue에 여전히 안전하게 남아있는다.
        
      
      최종 성공 시
        
          API 호출과 DB 기록이 모두 성공했을 때, 워커가 그제서야 processing-queue에서 작업 삭제한다.
          명령어: LREM worker-1-processing-queue 1 task-123
        
      
    
  
  
    워커 영구 장애 시 processing-queue 작업 정체

    현재는 worker-1-processing-queue 와 같이 워커별로 개별 큐를 두고 있다. (작업 소유권 명확해짐)

    문제점: 만약 worker-1이  작업을 processing-queue로 가져간 직후, 서버가 다운되어 영원히 복구되지 않으면 task-123 은 worker-1-processing-queue에 영원히 갇히게 된다. 다른 워커는 이 작업을 처리할 수 없다.

    보완책:

    
      일정 시간 이상 processing-queue 에 머물러 있는 작업을 감지하는 별도의 모니터링 스케줄러가 필요하다.
      이 스케줄러는 모든 worker-*-processing-queue 를 주기적으로 스캔한다.
      만약 특정 작업이 Timeout을 초과했다면, 해당 워커가 영구 장애 상태라고 간주하고 LMOVE를 사용해 해당 작업을 다시 main-queue 로 원자적으로 이동시킨다.
      타임아웃 초과 시 LMOVE worker-1-processing-queue main-queue LEFT RIGHT로 원자적으로 복구한다.
      이를 통해 다른 건강한 워커가 해당 작업을 이어받아 처리할 수 있다.
    
  




API 호출 실패 해결 방안

API 호출 실패를 일시적 실패와 영구적 실패로 분리하여, 시스템 전체가 멈추는 것을 막는다.

1. 즉시 재시도 하지 않는 이유


  API 호출이 실패했을 때, 그 자리에서 while 루프문을 돌며 즉시 재시도를 하는 것이다.
  문제점: 워커 스레드는 계속 실패한 작업에만 묶여있게 되므로 그동안 main-queue에 쌓인 나머지 작업은 처리하지 못한다.


2. retry-queue의 역할 (일시적 실패 처리)

retry-queue는 지금 당장 말고 나중에 다시 시도할 작업들을 모아둔다.


  API 호출이 일시적 실패로 끝났을 때 사용
    
      503 Service Unavailable (서버 과부하), Network Timeout (네트워크 불안정)
    
  
  동작:
    
      워커가 processing-queue의 작업으로 API 호출했으나 에러를 받는다.
      워커가 이 작업을 즉시 재시도 하지 않는다.
      대신, processing-queue 에서 이 작업을 꺼내어 retry-queue에 넣는다.
      워커는 이 실패한 작업을 잊고, 즉시 main-queue로 돌아가 다음 작업을 처리한다.
    
  
  retry-queue의 처리:
    
      이 큐는 별도의 워커(혹은 main-queue가 비었을 때만 이 큐를 보는 워커)가 처리한다.
      retry-queue에서 작업을 꺼낼 때는 지연을 주어서 꺼낸다.(ex: 5분 뒤에 다시 시도)
    
  


3. dlq-queue의 역할 (영구적 실패 격리)

dlq-queue (Dead Letter Queue)는 재시도를 해도 절대 성공할 수 없는 작업들을 모아두는 큐이다.


  API 호출이 영구적 실패로 끝났을 때 사용
    
      400 Bad Request (요청 형식이 잘못됨), 401 Unauthorized (API 키가 틀림), 404 Not Found (카카오 UUID가 존재하지 않음)
    
  
  이건 계속 재시도 해도 똑같이 실패할 것인 작업을 넣는다.
  동작:
    
      워커가 processing-queue의 작업으로 API 호출했으나 400 에러를 받는다.
      워커는 이 작업이 영구적 실패임을 인지한다.
      processing-queue에서 이 작업을 꺼내서 dlq-queue에 넣는다.(원자적)
      이 큐로 이동된 작업은 처리 “실패로 처리 완료된 작업”으로 간주한다. (워커는 main-queue로 복귀)
    
  
  dlq-queue의 처리:
    
      이 큐는 자동으로 처리되지 않는다.
      개발자가 수동으로 이 큐에 쌓인 작업들을 확인하여, 왜 특정 에러가 났는지 원인을 분석하고 버그를 수정한다.
    
  


4. 최대 재시도 횟수 관리

retry-queue에 있는 작업이 5분 뒤에 재시도했는데 또 503 에러를 받을 수도 있다.

→ 무한 재시도를 막아야 한다.

최대 재시도 횟수 로직을 통해 retry-queue와 dlq-queue 를 연결한다.


  최초 작업 페이로드에 retryCount: 0을 포함시킨다.
  N번 재시도 실패하면 영구적 실패로 간주하고 DLQ로 이동시킨다.


전체 흐름


  워커가 main-queue -&gt; processing-queue로 작업을 가져온다.
  API를 호출한다.
    
      (성공): processing-queue에서 작업 삭제. (완료)
      (영구적 실패 / 4xx): processing-queue -&gt; dlq-queue로 이동. (완료-실패)
      (일시적 실패 / 5xx): retryCount를 확인.
        
          count &lt; 3 : retryCount를 1 증가시키고 processing-queue -&gt; retry-queue로 이동.
          count &gt;= 3 : “최종 실패”로 간주. processing-queue -&gt; dlq-queue로 이동.
        
      
    
  


주의사항

processing-queue에서 이 작업을 꺼내어 retry-queue에 넣거나, retry-queue → dlq-queue 에 넣을때도 원자적이지 않으면 데이터가 유실 될 수 있다.

→ 해결책: LMOVE 사용


  main-queue → processing-queue로 가져올 때 BLMOVE를 사용한 것처럼, 다른 큐로 보낼 때도 원자적 이동 명령어를 사용해야 한다.


LMOVE (Non-Blocking) vs BLMOVE (Blocking)


  LMOVE
    
      소스 큐에서 아이템을 POP하여 목적지 큐로 PUSH한다.
      만약 소스 큐가 비어있으면: 즉시 nil(없음)을 반환하고 명령이 종료
    
  
  BLMOVE
    
      소스 큐에서 아이템을 POP하여 목적지 큐로 PUSH한다.
      만약 소스 큐가 비어있으면: 명령이 즉시 종료되지 않고, 데이터가 들어올 때까지 지정된 시간동안 대기한다.
    
  




작업 완료 처리 실패 해결 방안

최소 1회 전송을 보장하는 과정에서 중복 발송을 유발하는 실패 시나리오

→ 큐를 더 추가해서 해결하는 것이 아니라, 워커의 로직을 멱등성 있게 설계하여 해결한다.


  멱등성: 같은 작업을 여러 번 수행해도, 그 결과는 1번 수행한 것과 같아야 한다.


즉, 워커가 재시작되어 중복 발송을 시도하더라도, 실제 발송이 2번 일어나지 않게 방어하는 것



멱등성 검사를 통한 해결

워커는 작업을 처리할 때, 무조건 API부터 호출하는 것이 아니라 DB의 ‘최종 상태’를 먼저 확인해야 한다.


  [워커 재시작]
워커 A가 재시작된다.
  [백업 큐 확인]
로직 1순위로 worker-A-processing-queue를 확인(LRANGE 0 0)하고, API 호출/DB 기록/큐 삭제가 모두 실패했던 task-123을 발견한다.
  [멱등성 검사 (Idempotency Check)]
워커 A는 task-123을 보고 API를 바로 호출하지 않는다.
대신, task-123에 포함된 logId (예: 9876)를 가지고 quiz_notification_log DB를 먼저 조회한다.
SELECT status FROM quiz_notification_log WHERE id = 9876;
  [상태 확인 및 결정] 워커 A가 DB에서 조회한 status를 확인한다.
    
      CASE 1: status = 'SENT' (6단계 실패: 큐 삭제만 실패한 경우)
    
  


[방어 로직 실행]

- 워커 A는 API 발송도 성공했고 DB 기록도 성공했음을 알고 Redis 큐에서 삭제만 실패했던 것임을 인지한다.
- **카카오 API 호출을 절대로 하지 않는다. (SKIP)**
- 대신, **실패했던 마지막 단계(큐 삭제)만** 다시 수행한다.
- `LREM worker-A-processing-queue 1 task-123` 명령을 실행하여 백업 큐를 정리한다. - CASE 2: `status = 'PROCESSING'` (5단계 실패: SENT 기록만 실패한 경우)


PROCESSING 상태는 ‘보냈을 수도 있고 안 보냈을 수도 있는’ 애매한 상태라,

최소 1회 보장 원칙 때문에 중복 가능성을 감수하고 재호출한다

[방어 로직 실행]

- 워커 A는 “API 호출은 성공했을 수 있으나, DB SENT 기록은 실패했음”을 인지한다.
- ‘최소 1회 보장’ 원칙에 따라, 이 작업은 완료된 것이 아니므로 재시도한다.
- (중복 발송을 감수하고) API 호출부터 다시 시도한다.
- (API 호출 → DB SENT 변경 → LREM) - CASE 3: `status == 'QUEUED'` (매우 드문 경우: PROCESSING 변경조차 실패한 경우)


[방어 로직 실행]

- 워커 A는 “이 작업은 API 호출 시도조차 못했음”을 인지한다.
- 당연히 API 호출부터 다시 시도한다.
- (DB (`QUEUED` → `PROCESSING` )변경 → API 호출 → DB SENT 변경 → LREM)


주의사항

처음 큐에서 받은 작업이든, 재시작 후 발견한 작업이든, 워커는 항상 API 호출하기 직전에 DB의 status를 확인하는 것이 안전한 멱등성 설계이다.

→ 워커의 처리 로직을 단순하고 통일성 있게 유지할 수 있다.

→ 워커가 작업을 확보한 후 실행하는 로직은 항상 동일해야 한다. (분기 처리를 피함)

결론

워커가 작업 시작 전 DB 상태를 먼저 확인(SELECT)하는 멱등성 검사 로직을 가지고 있으면,
6단계 실패(API 호출과 DB 기록까지 성공)한 작업이 재시도되더라도, 워커가 SENT 상태를 감지하고 API 호출을 건너뛰어 중복 발송을 방지한다.
5단계 실패(API 호출 후 PROCESSING 상태에 멈춤)한 작업은, ‘최소 1회 보장’ 원칙에 따라 중복을 감수하고 재시도하여 메시지 누락을 방지한다.



                        </a>
                        <div class="info-post">
                                <a href="/Architecture" class="category">Architecture</a>
                            
                                <span class="date">· 2025-11-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>

    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture > Domain Design",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/Domain%20Design/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture > System Design",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/System%20Design/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture > data-modeling-erd",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/data-modeling-erd/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Architecture > security-auth",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Architecture/security-auth/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Spring Boot > Security",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Spring%20Boot/Security/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Spring Boot",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Spring%20Boot/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Trouble Shooting",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Trouble%20Shooting/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "[Java Concurrency] Thread.start()와 Thread 객체의 모니터 락 획득 과정",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, Concurrency, monitor lock, thread, synchronized, multi thread",
            'url'      : "/Java/thread-monitor-lock-1.html",
            'image'    : "/assets/img/thumbnail/thread-monitor-lock-1.png",
            'date'     : "2025-09-26"
        });
    

        posts.push({
            'title'    : "[Java Concurrency] 모니터 락과 wait/notifyAll로 턴 스케줄러 구현하기",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, Concurrency, monitor lock, wait-notifyAll",
            'url'      : "/Java/monitor-lock-1.html",
            'image'    : "/assets/img/thumbnail/monitor-lock-1.png",
            'date'     : "2025-09-30"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] Part 1 – Thread.start() vs run() : 자바 코드 + 간단한 흐름 비교",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part1-start-vs-run-code-and-flow.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-02"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] Part 2 – Thread.start() 뒤에서 일어나는 일: registerNatives ~ JVM_StartThread ~ JavaThread",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part2-start0-jvm-startthread-javathread.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-03"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] Part 3 – JVM이 OS 스레드를 만드는 과정: JavaThread, os::create_thread, pthread_create, glibc, clone()",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part3-os-create-thread-pthread-glibc-clone.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-04"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] Part 4 – 새로운 스레드가 자바 run()에 도달하기까지: thread_native_entry → JavaThread::run → thread_entry → Thread.run()",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part4-thread-entry-to-run.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-04"
        });
    

        posts.push({
            'title'    : "[Java Multithreading] 마지막 글 - 스레드 관점에서 한눈에 정리: new → start → run → 종료 후 상태",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, concurrency, thread, start, run, jvm",
            'url'      : "/Java/java-thread-start-part5-thread-lifecycle-summary.html",
            'image'    : "/assets/img/thumbnail/thread-start.png",
            'date'     : "2025-10-06"
        });
    

        posts.push({
            'title'    : "[Firebase/Java] Firestore ApiFuture와 Java Future, 그리고 Reactor Mono까지 – 비동기 흐름 뜯어보기",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, firestore, apifuture, future, listenablefuture, reactor, mono, async, concurrency",
            'url'      : "/Java/firestore-apifuture-future-mono-async-flow.html",
            'image'    : "/assets/img/thumbnail/firestore-apifuture-future-mono-async-flow.png",
            'date'     : "2025-10-25"
        });
    

        posts.push({
            'title'    : "[시스템 설계] 하루 한 번 알림을 “누락 없이” 보내기 위한 Redis 큐 &amp; 워커 설계",
            'path'     : "Architecture > System Design",
            'type'     : "post",
            'tags'     : "redis, worker, at-least-once-notification, spring schedule, blmove, redis-queue-blmove-idempotency",
            'url'      : "/Architecture/System%20Design/at-least-once-notification-redis-queue-blmove-idempotency.html",
            'image'    : "/assets/img/thumbnail/at-least-once-notification-redis-queue-blmove-idempotency.png",
            'date'     : "2025-11-03"
        });
    

        posts.push({
            'title'    : "카카오 OAuth 로그인 흐름 이해하기: JS SDK + Authorization Code 플로우",
            'path'     : "Architecture > security-auth",
            'type'     : "post",
            'tags'     : "springboot, spring-security, oauth2, kakao, login, diagram",
            'url'      : "/Architecture/security-auth/2025-11-30-kakao-login.html",
            'image'    : "/assets/img/thumbnail/2025-11-30-kakao-login.png",
            'date'     : "2025-11-30"
        });
    

        posts.push({
            'title'    : "[Docker Troubleshooting] Spring Redis UnknownHostException 해결기: Spring 앱과 Redis의 외부 네트워크와 DNS 스코프 문제",
            'path'     : "Trouble Shooting",
            'type'     : "post",
            'tags'     : "docker, docker-compose, redis, spring, networking, dns, ec2, devops, troubleshooting",
            'url'      : "/Trouble%20Shooting/docker-redis-network-dns.html",
            'image'    : "/assets/img/thumbnail/docker-redis-network-dns.png",
            'date'     : "2025-12-08"
        });
    

        posts.push({
            'title'    : "[Troubleshooting] Nginx로 HTTPS→HTTP 프록시 구성해 Mixed Content 해결하기 (도메인 없이 nip.io 사용)",
            'path'     : "Trouble Shooting",
            'type'     : "post",
            'tags'     : "trouble shooting, nginx, https, nip.io, docker, devops, ssl, ec2, aws",
            'url'      : "/Trouble%20Shooting/nginx-https-without-domain-nip-io.html",
            'image'    : "/assets/img/thumbnail/nginx-https-without-domain-nip-io.png",
            'date'     : "2025-12-09"
        });
    

        posts.push({
            'title'    : "[ONECO DDD 도메인 설계 시리즈 Part 1] DailyContent 애그리거트 설계 스토리",
            'path'     : "Architecture > Domain Design",
            'type'     : "post",
            'tags'     : "DDD, domain-driven design, domain design, architecture, aggregate, domain model, entity, value object",
            'url'      : "/Architecture/Domain%20Design/oneco-ddd-dailycontent-1.html",
            'image'    : "/assets/img/thumbnail/oneco-ddd-dailycontent.png",
            'date'     : "2025-12-11"
        });
    

        posts.push({
            'title'    : "[ONECO DDD 도메인 설계 시리즈 Part 2] DailyContent 애그리거트 뜯어보기",
            'path'     : "Architecture > Domain Design",
            'type'     : "post",
            'tags'     : "DDD, domain-driven design, domain design, architecture, aggregate, domain model, entity",
            'url'      : "/Architecture/Domain%20Design/oneco-ddd-dailycontent-2.html",
            'image'    : "/assets/img/thumbnail/oneco-ddd-dailycontent.png",
            'date'     : "2025-12-12"
        });
    

    searchPost(posts);

    
</script>
    <script type="module">
        import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
        document.addEventListener("DOMContentLoaded", function () {
            mermaid.initialize({ startOnLoad: true });
        });
    </script>
</html>
